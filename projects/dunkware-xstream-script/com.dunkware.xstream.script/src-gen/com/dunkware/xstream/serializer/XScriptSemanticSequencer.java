/*
 * generated by Xtext 2.21.0
 */
package com.dunkware.xstream.serializer;

import com.dunkware.xstream.services.XScriptGrammarAccess;
import com.dunkware.xstream.xScript.AndType;
import com.dunkware.xstream.xScript.AvgExpressionType;
import com.dunkware.xstream.xScript.BoolConstantType;
import com.dunkware.xstream.xScript.ComparisonType;
import com.dunkware.xstream.xScript.DoubleConstantType;
import com.dunkware.xstream.xScript.EqualityType;
import com.dunkware.xstream.xScript.IntConstantType;
import com.dunkware.xstream.xScript.MinusType;
import com.dunkware.xstream.xScript.MulOrDivType;
import com.dunkware.xstream.xScript.NotType;
import com.dunkware.xstream.xScript.OrType;
import com.dunkware.xstream.xScript.PlusType;
import com.dunkware.xstream.xScript.RocExpressionType;
import com.dunkware.xstream.xScript.SessionSignalExpressionType;
import com.dunkware.xstream.xScript.SetExpressionType;
import com.dunkware.xstream.xScript.SignalType;
import com.dunkware.xstream.xScript.SnapshotExpressionType;
import com.dunkware.xstream.xScript.StringConstantType;
import com.dunkware.xstream.xScript.SubExpressionType;
import com.dunkware.xstream.xScript.TickExpressionType;
import com.dunkware.xstream.xScript.VarType;
import com.dunkware.xstream.xScript.VariableValueExpType;
import com.dunkware.xstream.xScript.VariableValueRangeType;
import com.dunkware.xstream.xScript.VariableValueType;
import com.dunkware.xstream.xScript.XAndType;
import com.dunkware.xstream.xScript.XBoolConstantType;
import com.dunkware.xstream.xScript.XClassType;
import com.dunkware.xstream.xScript.XComparisonType;
import com.dunkware.xstream.xScript.XDebugType;
import com.dunkware.xstream.xScript.XDoubleConstantType;
import com.dunkware.xstream.xScript.XElseIfStatementType;
import com.dunkware.xstream.xScript.XElseStatementType;
import com.dunkware.xstream.xScript.XEqualityType;
import com.dunkware.xstream.xScript.XFunctionCallExpType;
import com.dunkware.xstream.xScript.XFunctionCallType;
import com.dunkware.xstream.xScript.XFunctionReturnType;
import com.dunkware.xstream.xScript.XFunctionStartType;
import com.dunkware.xstream.xScript.XFunctionType;
import com.dunkware.xstream.xScript.XIfStatementType;
import com.dunkware.xstream.xScript.XIntConstantType;
import com.dunkware.xstream.xScript.XLastSignalTriggerType;
import com.dunkware.xstream.xScript.XMinusType;
import com.dunkware.xstream.xScript.XMulOrDivType;
import com.dunkware.xstream.xScript.XNotType;
import com.dunkware.xstream.xScript.XOrType;
import com.dunkware.xstream.xScript.XPercentChangeExpType;
import com.dunkware.xstream.xScript.XPlusType;
import com.dunkware.xstream.xScript.XQueryFilterValueCompareType;
import com.dunkware.xstream.xScript.XQueryFilterValueType;
import com.dunkware.xstream.xScript.XQueryType;
import com.dunkware.xstream.xScript.XRocExpType;
import com.dunkware.xstream.xScript.XScript;
import com.dunkware.xstream.xScript.XScriptPackage;
import com.dunkware.xstream.xScript.XSetVarType;
import com.dunkware.xstream.xScript.XSignalListenerType;
import com.dunkware.xstream.xScript.XSignalTriggerCountType;
import com.dunkware.xstream.xScript.XSignalTriggerType;
import com.dunkware.xstream.xScript.XSleepType;
import com.dunkware.xstream.xScript.XSlrAvgExpType;
import com.dunkware.xstream.xScript.XStreamVarListenerType;
import com.dunkware.xstream.xScript.XStreamVarValueExpType;
import com.dunkware.xstream.xScript.XStreamWrapperExpType;
import com.dunkware.xstream.xScript.XStringConstantType;
import com.dunkware.xstream.xScript.XSubExpType;
import com.dunkware.xstream.xScript.XTimeRangeRelative;
import com.dunkware.xstream.xScript.XValueHistoricalSignalCountType;
import com.dunkware.xstream.xScript.XValueHistoricalVarAggType;
import com.dunkware.xstream.xScript.XValueSessionSignalCountType;
import com.dunkware.xstream.xScript.XValueSessionVarAggType;
import com.dunkware.xstream.xScript.XValueSessionVarValueType;
import com.dunkware.xstream.xScript.XVarCompareStreakType;
import com.dunkware.xstream.xScript.XVarDecrementType;
import com.dunkware.xstream.xScript.XVarExpType;
import com.dunkware.xstream.xScript.XVarIncrementType;
import com.dunkware.xstream.xScript.XVarSetterType;
import com.dunkware.xstream.xScript.XVarStreakCompareType;
import com.dunkware.xstream.xScript.XVarStreakType;
import com.dunkware.xstream.xScript.XVarStreakValueType;
import com.dunkware.xstream.xScript.XVarType;
import com.dunkware.xstream.xScript.XVarianceAverageType;
import com.dunkware.xstream.xScript.XVarianceMaxType;
import com.dunkware.xstream.xScript.XWhileBreakType;
import com.dunkware.xstream.xScript.XWhileType;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XScriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XScriptPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XScriptPackage.AND_TYPE:
				sequence_AndType(context, (AndType) semanticObject); 
				return; 
			case XScriptPackage.AVG_EXPRESSION_TYPE:
				sequence_AvgExpressionType(context, (AvgExpressionType) semanticObject); 
				return; 
			case XScriptPackage.BOOL_CONSTANT_TYPE:
				sequence_AtomicBaseType(context, (BoolConstantType) semanticObject); 
				return; 
			case XScriptPackage.COMPARISON_TYPE:
				sequence_ComparisonType(context, (ComparisonType) semanticObject); 
				return; 
			case XScriptPackage.DOUBLE_CONSTANT_TYPE:
				sequence_AtomicBaseType(context, (DoubleConstantType) semanticObject); 
				return; 
			case XScriptPackage.EQUALITY_TYPE:
				sequence_EqualityType(context, (EqualityType) semanticObject); 
				return; 
			case XScriptPackage.INT_CONSTANT_TYPE:
				sequence_AtomicBaseType(context, (IntConstantType) semanticObject); 
				return; 
			case XScriptPackage.MINUS_TYPE:
				sequence_PlusOrMinusType(context, (MinusType) semanticObject); 
				return; 
			case XScriptPackage.MUL_OR_DIV_TYPE:
				sequence_MulOrDivType(context, (MulOrDivType) semanticObject); 
				return; 
			case XScriptPackage.NOT_TYPE:
				sequence_PrimaryType(context, (NotType) semanticObject); 
				return; 
			case XScriptPackage.OR_TYPE:
				sequence_OrType(context, (OrType) semanticObject); 
				return; 
			case XScriptPackage.PLUS_TYPE:
				sequence_PlusOrMinusType(context, (PlusType) semanticObject); 
				return; 
			case XScriptPackage.ROC_EXPRESSION_TYPE:
				sequence_RocExpressionType(context, (RocExpressionType) semanticObject); 
				return; 
			case XScriptPackage.SESSION_SIGNAL_EXPRESSION_TYPE:
				sequence_SessionSignalExpressionType(context, (SessionSignalExpressionType) semanticObject); 
				return; 
			case XScriptPackage.SET_EXPRESSION_TYPE:
				sequence_SetExpressionType(context, (SetExpressionType) semanticObject); 
				return; 
			case XScriptPackage.SIGNAL_TYPE:
				sequence_SignalType(context, (SignalType) semanticObject); 
				return; 
			case XScriptPackage.SNAPSHOT_EXPRESSION_TYPE:
				sequence_SnapshotExpressionType(context, (SnapshotExpressionType) semanticObject); 
				return; 
			case XScriptPackage.STRING_CONSTANT_TYPE:
				sequence_AtomicBaseType(context, (StringConstantType) semanticObject); 
				return; 
			case XScriptPackage.SUB_EXPRESSION_TYPE:
				sequence_SubExpressionType(context, (SubExpressionType) semanticObject); 
				return; 
			case XScriptPackage.TICK_EXPRESSION_TYPE:
				sequence_TickExpressionType(context, (TickExpressionType) semanticObject); 
				return; 
			case XScriptPackage.VAR_TYPE:
				sequence_VarType(context, (VarType) semanticObject); 
				return; 
			case XScriptPackage.VARIABLE_VALUE_EXP_TYPE:
				sequence_VariableValueExpType(context, (VariableValueExpType) semanticObject); 
				return; 
			case XScriptPackage.VARIABLE_VALUE_RANGE_TYPE:
				sequence_VariableValueRangeType(context, (VariableValueRangeType) semanticObject); 
				return; 
			case XScriptPackage.VARIABLE_VALUE_TYPE:
				sequence_VariableValueType(context, (VariableValueType) semanticObject); 
				return; 
			case XScriptPackage.XAND_TYPE:
				sequence_XAndType(context, (XAndType) semanticObject); 
				return; 
			case XScriptPackage.XBOOL_CONSTANT_TYPE:
				sequence_XAtomicBaseType(context, (XBoolConstantType) semanticObject); 
				return; 
			case XScriptPackage.XCLASS_TYPE:
				sequence_XClassType(context, (XClassType) semanticObject); 
				return; 
			case XScriptPackage.XCOMPARISON_TYPE:
				sequence_XComparisonType(context, (XComparisonType) semanticObject); 
				return; 
			case XScriptPackage.XDEBUG_TYPE:
				sequence_XDebugType(context, (XDebugType) semanticObject); 
				return; 
			case XScriptPackage.XDOUBLE_CONSTANT_TYPE:
				sequence_XAtomicBaseType(context, (XDoubleConstantType) semanticObject); 
				return; 
			case XScriptPackage.XELSE_IF_STATEMENT_TYPE:
				sequence_XElseIfStatementType(context, (XElseIfStatementType) semanticObject); 
				return; 
			case XScriptPackage.XELSE_STATEMENT_TYPE:
				sequence_XElseStatementType(context, (XElseStatementType) semanticObject); 
				return; 
			case XScriptPackage.XEQUALITY_TYPE:
				sequence_XEqualityType(context, (XEqualityType) semanticObject); 
				return; 
			case XScriptPackage.XFUNCTION_CALL_EXP_TYPE:
				sequence_XFunctionCallExpType(context, (XFunctionCallExpType) semanticObject); 
				return; 
			case XScriptPackage.XFUNCTION_CALL_TYPE:
				sequence_XFunctionCallType(context, (XFunctionCallType) semanticObject); 
				return; 
			case XScriptPackage.XFUNCTION_RETURN_TYPE:
				sequence_XFunctionReturnType(context, (XFunctionReturnType) semanticObject); 
				return; 
			case XScriptPackage.XFUNCTION_START_TYPE:
				sequence_XFunctionStartType(context, (XFunctionStartType) semanticObject); 
				return; 
			case XScriptPackage.XFUNCTION_TYPE:
				sequence_XFunctionType(context, (XFunctionType) semanticObject); 
				return; 
			case XScriptPackage.XIF_STATEMENT_TYPE:
				sequence_XIfStatementType(context, (XIfStatementType) semanticObject); 
				return; 
			case XScriptPackage.XINT_CONSTANT_TYPE:
				sequence_XAtomicBaseType(context, (XIntConstantType) semanticObject); 
				return; 
			case XScriptPackage.XLAST_SIGNAL_TRIGGER_TYPE:
				sequence_XLastSignalTriggerType(context, (XLastSignalTriggerType) semanticObject); 
				return; 
			case XScriptPackage.XMINUS_TYPE:
				sequence_XPlusOrMinusType(context, (XMinusType) semanticObject); 
				return; 
			case XScriptPackage.XMUL_OR_DIV_TYPE:
				sequence_XMulOrDivType(context, (XMulOrDivType) semanticObject); 
				return; 
			case XScriptPackage.XNOT_TYPE:
				sequence_XPrimaryType(context, (XNotType) semanticObject); 
				return; 
			case XScriptPackage.XOR_TYPE:
				sequence_XOrType(context, (XOrType) semanticObject); 
				return; 
			case XScriptPackage.XPERCENT_CHANGE_EXP_TYPE:
				sequence_XPercentChangeExpType(context, (XPercentChangeExpType) semanticObject); 
				return; 
			case XScriptPackage.XPLUS_TYPE:
				sequence_XPlusOrMinusType(context, (XPlusType) semanticObject); 
				return; 
			case XScriptPackage.XQUERY_FILTER_VALUE_COMPARE_TYPE:
				sequence_XQueryFilterValueCompareType(context, (XQueryFilterValueCompareType) semanticObject); 
				return; 
			case XScriptPackage.XQUERY_FILTER_VALUE_TYPE:
				sequence_XQueryFilterValueType(context, (XQueryFilterValueType) semanticObject); 
				return; 
			case XScriptPackage.XQUERY_TYPE:
				sequence_XQueryType(context, (XQueryType) semanticObject); 
				return; 
			case XScriptPackage.XROC_EXP_TYPE:
				sequence_XRocExpType(context, (XRocExpType) semanticObject); 
				return; 
			case XScriptPackage.XSCRIPT:
				sequence_XScript(context, (XScript) semanticObject); 
				return; 
			case XScriptPackage.XSET_VAR_TYPE:
				sequence_XSetVarType(context, (XSetVarType) semanticObject); 
				return; 
			case XScriptPackage.XSIGNAL_LISTENER_TYPE:
				sequence_XSignalListenerType(context, (XSignalListenerType) semanticObject); 
				return; 
			case XScriptPackage.XSIGNAL_TRIGGER_COUNT_TYPE:
				sequence_XSignalTriggerCountType(context, (XSignalTriggerCountType) semanticObject); 
				return; 
			case XScriptPackage.XSIGNAL_TRIGGER_TYPE:
				sequence_XSignalTriggerType(context, (XSignalTriggerType) semanticObject); 
				return; 
			case XScriptPackage.XSLEEP_TYPE:
				sequence_XSleepType(context, (XSleepType) semanticObject); 
				return; 
			case XScriptPackage.XSLR_AVG_EXP_TYPE:
				sequence_XSlrAvgExpType(context, (XSlrAvgExpType) semanticObject); 
				return; 
			case XScriptPackage.XSTREAM_VAR_LISTENER_TYPE:
				sequence_XStreamVarListenerType(context, (XStreamVarListenerType) semanticObject); 
				return; 
			case XScriptPackage.XSTREAM_VAR_VALUE_EXP_TYPE:
				sequence_XStreamVarValueExpType(context, (XStreamVarValueExpType) semanticObject); 
				return; 
			case XScriptPackage.XSTREAM_WRAPPER_EXP_TYPE:
				sequence_XStreamWrapperExpType(context, (XStreamWrapperExpType) semanticObject); 
				return; 
			case XScriptPackage.XSTRING_CONSTANT_TYPE:
				sequence_XAtomicBaseType(context, (XStringConstantType) semanticObject); 
				return; 
			case XScriptPackage.XSUB_EXP_TYPE:
				sequence_XSubExpType(context, (XSubExpType) semanticObject); 
				return; 
			case XScriptPackage.XTIME_RANGE_RELATIVE:
				sequence_XTimeRangeRelative(context, (XTimeRangeRelative) semanticObject); 
				return; 
			case XScriptPackage.XVALUE_HISTORICAL_SIGNAL_COUNT_TYPE:
				sequence_XValueHistoricalSignalCountType(context, (XValueHistoricalSignalCountType) semanticObject); 
				return; 
			case XScriptPackage.XVALUE_HISTORICAL_VAR_AGG_TYPE:
				sequence_XValueHistoricalVarAggType(context, (XValueHistoricalVarAggType) semanticObject); 
				return; 
			case XScriptPackage.XVALUE_SESSION_SIGNAL_COUNT_TYPE:
				sequence_XValueSessionSignalCountType(context, (XValueSessionSignalCountType) semanticObject); 
				return; 
			case XScriptPackage.XVALUE_SESSION_VAR_AGG_TYPE:
				sequence_XValueSessionVarAggType(context, (XValueSessionVarAggType) semanticObject); 
				return; 
			case XScriptPackage.XVALUE_SESSION_VAR_VALUE_TYPE:
				sequence_XValueSessionVarValueType(context, (XValueSessionVarValueType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_COMPARE_STREAK_TYPE:
				sequence_XVarCompareStreakType(context, (XVarCompareStreakType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_DECREMENT_TYPE:
				sequence_XVarDecrementType(context, (XVarDecrementType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_EXP_TYPE:
				sequence_XVarExpType(context, (XVarExpType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_INCREMENT_TYPE:
				sequence_XVarIncrementType(context, (XVarIncrementType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_SETTER_TYPE:
				sequence_XVarSetterType(context, (XVarSetterType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_STREAK_COMPARE_TYPE:
				sequence_XVarStreakCompareType(context, (XVarStreakCompareType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_STREAK_TYPE:
				sequence_XVarStreakType(context, (XVarStreakType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_STREAK_VALUE_TYPE:
				sequence_XVarStreakValueType(context, (XVarStreakValueType) semanticObject); 
				return; 
			case XScriptPackage.XVAR_TYPE:
				sequence_XVarType(context, (XVarType) semanticObject); 
				return; 
			case XScriptPackage.XVARIANCE_AVERAGE_TYPE:
				sequence_XVarianceAverageType(context, (XVarianceAverageType) semanticObject); 
				return; 
			case XScriptPackage.XVARIANCE_MAX_TYPE:
				sequence_XVarianceMaxType(context, (XVarianceMaxType) semanticObject); 
				return; 
			case XScriptPackage.XWHILE_BREAK_TYPE:
				sequence_XWhileBreakType(context, (XWhileBreakType) semanticObject); 
				return; 
			case XScriptPackage.XWHILE_TYPE:
				sequence_XWhileType(context, (XWhileType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ExpressionType returns AndType
	 *     OrType returns AndType
	 *     OrType.OrType_1_0 returns AndType
	 *     AndType returns AndType
	 *     AndType.AndType_1_0 returns AndType
	 *     EqualityType returns AndType
	 *     EqualityType.EqualityType_1_0 returns AndType
	 *     ComparisonType returns AndType
	 *     ComparisonType.ComparisonType_1_0 returns AndType
	 *     PlusOrMinusType returns AndType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns AndType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns AndType
	 *     MulOrDivType returns AndType
	 *     MulOrDivType.MulOrDivType_1_0 returns AndType
	 *     PrimaryType returns AndType
	 *
	 * Constraint:
	 *     (left=AndType_AndType_1_0 right=EqualityType)
	 */
	protected void sequence_AndType(ISerializationContext context, AndType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.AND_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.AND_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.AND_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.AND_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndTypeAccess().getAndTypeLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndTypeAccess().getRightEqualityTypeParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns BoolConstantType
	 *     OrType returns BoolConstantType
	 *     OrType.OrType_1_0 returns BoolConstantType
	 *     AndType returns BoolConstantType
	 *     AndType.AndType_1_0 returns BoolConstantType
	 *     EqualityType returns BoolConstantType
	 *     EqualityType.EqualityType_1_0 returns BoolConstantType
	 *     ComparisonType returns BoolConstantType
	 *     ComparisonType.ComparisonType_1_0 returns BoolConstantType
	 *     PlusOrMinusType returns BoolConstantType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns BoolConstantType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns BoolConstantType
	 *     MulOrDivType returns BoolConstantType
	 *     MulOrDivType.MulOrDivType_1_0 returns BoolConstantType
	 *     PrimaryType returns BoolConstantType
	 *     AtomicType returns BoolConstantType
	 *     AtomicBaseType returns BoolConstantType
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_AtomicBaseType(ISerializationContext context, BoolConstantType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns DoubleConstantType
	 *     OrType returns DoubleConstantType
	 *     OrType.OrType_1_0 returns DoubleConstantType
	 *     AndType returns DoubleConstantType
	 *     AndType.AndType_1_0 returns DoubleConstantType
	 *     EqualityType returns DoubleConstantType
	 *     EqualityType.EqualityType_1_0 returns DoubleConstantType
	 *     ComparisonType returns DoubleConstantType
	 *     ComparisonType.ComparisonType_1_0 returns DoubleConstantType
	 *     PlusOrMinusType returns DoubleConstantType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns DoubleConstantType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns DoubleConstantType
	 *     MulOrDivType returns DoubleConstantType
	 *     MulOrDivType.MulOrDivType_1_0 returns DoubleConstantType
	 *     PrimaryType returns DoubleConstantType
	 *     AtomicType returns DoubleConstantType
	 *     AtomicBaseType returns DoubleConstantType
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_AtomicBaseType(ISerializationContext context, DoubleConstantType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.DOUBLE_CONSTANT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.DOUBLE_CONSTANT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicBaseTypeAccess().getValueDOUBLETerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns IntConstantType
	 *     OrType returns IntConstantType
	 *     OrType.OrType_1_0 returns IntConstantType
	 *     AndType returns IntConstantType
	 *     AndType.AndType_1_0 returns IntConstantType
	 *     EqualityType returns IntConstantType
	 *     EqualityType.EqualityType_1_0 returns IntConstantType
	 *     ComparisonType returns IntConstantType
	 *     ComparisonType.ComparisonType_1_0 returns IntConstantType
	 *     PlusOrMinusType returns IntConstantType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns IntConstantType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns IntConstantType
	 *     MulOrDivType returns IntConstantType
	 *     MulOrDivType.MulOrDivType_1_0 returns IntConstantType
	 *     PrimaryType returns IntConstantType
	 *     AtomicType returns IntConstantType
	 *     AtomicBaseType returns IntConstantType
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicBaseType(ISerializationContext context, IntConstantType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.INT_CONSTANT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.INT_CONSTANT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicBaseTypeAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns StringConstantType
	 *     OrType returns StringConstantType
	 *     OrType.OrType_1_0 returns StringConstantType
	 *     AndType returns StringConstantType
	 *     AndType.AndType_1_0 returns StringConstantType
	 *     EqualityType returns StringConstantType
	 *     EqualityType.EqualityType_1_0 returns StringConstantType
	 *     ComparisonType returns StringConstantType
	 *     ComparisonType.ComparisonType_1_0 returns StringConstantType
	 *     PlusOrMinusType returns StringConstantType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns StringConstantType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns StringConstantType
	 *     MulOrDivType returns StringConstantType
	 *     MulOrDivType.MulOrDivType_1_0 returns StringConstantType
	 *     PrimaryType returns StringConstantType
	 *     AtomicType returns StringConstantType
	 *     AtomicBaseType returns StringConstantType
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicBaseType(ISerializationContext context, StringConstantType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.STRING_CONSTANT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.STRING_CONSTANT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicBaseTypeAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns AvgExpressionType
	 *     OrType returns AvgExpressionType
	 *     OrType.OrType_1_0 returns AvgExpressionType
	 *     AndType returns AvgExpressionType
	 *     AndType.AndType_1_0 returns AvgExpressionType
	 *     EqualityType returns AvgExpressionType
	 *     EqualityType.EqualityType_1_0 returns AvgExpressionType
	 *     ComparisonType returns AvgExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns AvgExpressionType
	 *     PlusOrMinusType returns AvgExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns AvgExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns AvgExpressionType
	 *     MulOrDivType returns AvgExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns AvgExpressionType
	 *     PrimaryType returns AvgExpressionType
	 *     AtomicType returns AvgExpressionType
	 *     AtomicBaseType returns AvgExpressionType
	 *     AvgExpressionType returns AvgExpressionType
	 *
	 * Constraint:
	 *     target=SetExpressionType
	 */
	protected void sequence_AvgExpressionType(ISerializationContext context, AvgExpressionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.AVG_EXPRESSION_TYPE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.AVG_EXPRESSION_TYPE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAvgExpressionTypeAccess().getTargetSetExpressionTypeParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns ComparisonType
	 *     OrType returns ComparisonType
	 *     OrType.OrType_1_0 returns ComparisonType
	 *     AndType returns ComparisonType
	 *     AndType.AndType_1_0 returns ComparisonType
	 *     EqualityType returns ComparisonType
	 *     EqualityType.EqualityType_1_0 returns ComparisonType
	 *     ComparisonType returns ComparisonType
	 *     ComparisonType.ComparisonType_1_0 returns ComparisonType
	 *     PlusOrMinusType returns ComparisonType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns ComparisonType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns ComparisonType
	 *     MulOrDivType returns ComparisonType
	 *     MulOrDivType.MulOrDivType_1_0 returns ComparisonType
	 *     PrimaryType returns ComparisonType
	 *
	 * Constraint:
	 *     (left=ComparisonType_ComparisonType_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinusType)
	 */
	protected void sequence_ComparisonType(ISerializationContext context, ComparisonType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns EqualityType
	 *     OrType returns EqualityType
	 *     OrType.OrType_1_0 returns EqualityType
	 *     AndType returns EqualityType
	 *     AndType.AndType_1_0 returns EqualityType
	 *     EqualityType returns EqualityType
	 *     EqualityType.EqualityType_1_0 returns EqualityType
	 *     ComparisonType returns EqualityType
	 *     ComparisonType.ComparisonType_1_0 returns EqualityType
	 *     PlusOrMinusType returns EqualityType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns EqualityType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns EqualityType
	 *     MulOrDivType returns EqualityType
	 *     MulOrDivType.MulOrDivType_1_0 returns EqualityType
	 *     PrimaryType returns EqualityType
	 *
	 * Constraint:
	 *     (left=EqualityType_EqualityType_1_0 (op='==' | op='!=') right=ComparisonType)
	 */
	protected void sequence_EqualityType(ISerializationContext context, EqualityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns MulOrDivType
	 *     OrType returns MulOrDivType
	 *     OrType.OrType_1_0 returns MulOrDivType
	 *     AndType returns MulOrDivType
	 *     AndType.AndType_1_0 returns MulOrDivType
	 *     EqualityType returns MulOrDivType
	 *     EqualityType.EqualityType_1_0 returns MulOrDivType
	 *     ComparisonType returns MulOrDivType
	 *     ComparisonType.ComparisonType_1_0 returns MulOrDivType
	 *     PlusOrMinusType returns MulOrDivType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns MulOrDivType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns MulOrDivType
	 *     MulOrDivType returns MulOrDivType
	 *     MulOrDivType.MulOrDivType_1_0 returns MulOrDivType
	 *     PrimaryType returns MulOrDivType
	 *
	 * Constraint:
	 *     (left=MulOrDivType_MulOrDivType_1_0 (op='*' | op='/') right=PrimaryType)
	 */
	protected void sequence_MulOrDivType(ISerializationContext context, MulOrDivType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns OrType
	 *     OrType returns OrType
	 *     OrType.OrType_1_0 returns OrType
	 *     AndType returns OrType
	 *     AndType.AndType_1_0 returns OrType
	 *     EqualityType returns OrType
	 *     EqualityType.EqualityType_1_0 returns OrType
	 *     ComparisonType returns OrType
	 *     ComparisonType.ComparisonType_1_0 returns OrType
	 *     PlusOrMinusType returns OrType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns OrType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns OrType
	 *     MulOrDivType returns OrType
	 *     MulOrDivType.MulOrDivType_1_0 returns OrType
	 *     PrimaryType returns OrType
	 *
	 * Constraint:
	 *     (left=OrType_OrType_1_0 right=AndType)
	 */
	protected void sequence_OrType(ISerializationContext context, OrType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.OR_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.OR_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.OR_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.OR_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrTypeAccess().getOrTypeLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrTypeAccess().getRightAndTypeParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns MinusType
	 *     OrType returns MinusType
	 *     OrType.OrType_1_0 returns MinusType
	 *     AndType returns MinusType
	 *     AndType.AndType_1_0 returns MinusType
	 *     EqualityType returns MinusType
	 *     EqualityType.EqualityType_1_0 returns MinusType
	 *     ComparisonType returns MinusType
	 *     ComparisonType.ComparisonType_1_0 returns MinusType
	 *     PlusOrMinusType returns MinusType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns MinusType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns MinusType
	 *     MulOrDivType returns MinusType
	 *     MulOrDivType.MulOrDivType_1_0 returns MinusType
	 *     PrimaryType returns MinusType
	 *
	 * Constraint:
	 *     (left=PlusOrMinusType_MinusType_1_0_1_0 right=MulOrDivType)
	 */
	protected void sequence_PlusOrMinusType(ISerializationContext context, MinusType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.MINUS_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.MINUS_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.MINUS_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.MINUS_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusTypeAccess().getMinusTypeLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusTypeAccess().getRightMulOrDivTypeParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns PlusType
	 *     OrType returns PlusType
	 *     OrType.OrType_1_0 returns PlusType
	 *     AndType returns PlusType
	 *     AndType.AndType_1_0 returns PlusType
	 *     EqualityType returns PlusType
	 *     EqualityType.EqualityType_1_0 returns PlusType
	 *     ComparisonType returns PlusType
	 *     ComparisonType.ComparisonType_1_0 returns PlusType
	 *     PlusOrMinusType returns PlusType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns PlusType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns PlusType
	 *     MulOrDivType returns PlusType
	 *     MulOrDivType.MulOrDivType_1_0 returns PlusType
	 *     PrimaryType returns PlusType
	 *
	 * Constraint:
	 *     (left=PlusOrMinusType_PlusType_1_0_0_0 right=MulOrDivType)
	 */
	protected void sequence_PlusOrMinusType(ISerializationContext context, PlusType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.PLUS_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.PLUS_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.PLUS_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.PLUS_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusTypeAccess().getPlusTypeLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusTypeAccess().getRightMulOrDivTypeParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns NotType
	 *     OrType returns NotType
	 *     OrType.OrType_1_0 returns NotType
	 *     AndType returns NotType
	 *     AndType.AndType_1_0 returns NotType
	 *     EqualityType returns NotType
	 *     EqualityType.EqualityType_1_0 returns NotType
	 *     ComparisonType returns NotType
	 *     ComparisonType.ComparisonType_1_0 returns NotType
	 *     PlusOrMinusType returns NotType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns NotType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns NotType
	 *     MulOrDivType returns NotType
	 *     MulOrDivType.MulOrDivType_1_0 returns NotType
	 *     PrimaryType returns NotType
	 *
	 * Constraint:
	 *     expression=PrimaryType
	 */
	protected void sequence_PrimaryType(ISerializationContext context, NotType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.NOT_TYPE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.NOT_TYPE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryTypeAccess().getExpressionPrimaryTypeParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns RocExpressionType
	 *     OrType returns RocExpressionType
	 *     OrType.OrType_1_0 returns RocExpressionType
	 *     AndType returns RocExpressionType
	 *     AndType.AndType_1_0 returns RocExpressionType
	 *     EqualityType returns RocExpressionType
	 *     EqualityType.EqualityType_1_0 returns RocExpressionType
	 *     ComparisonType returns RocExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns RocExpressionType
	 *     PlusOrMinusType returns RocExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns RocExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns RocExpressionType
	 *     MulOrDivType returns RocExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns RocExpressionType
	 *     PrimaryType returns RocExpressionType
	 *     AtomicType returns RocExpressionType
	 *     AtomicBaseType returns RocExpressionType
	 *     RocExpressionType returns RocExpressionType
	 *
	 * Constraint:
	 *     (target=ExpressionType compare=ExpressionType)
	 */
	protected void sequence_RocExpressionType(ISerializationContext context, RocExpressionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.ROC_EXPRESSION_TYPE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.ROC_EXPRESSION_TYPE__TARGET));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.ROC_EXPRESSION_TYPE__COMPARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.ROC_EXPRESSION_TYPE__COMPARE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRocExpressionTypeAccess().getTargetExpressionTypeParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getRocExpressionTypeAccess().getCompareExpressionTypeParserRuleCall_5_0(), semanticObject.getCompare());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns SessionSignalExpressionType
	 *     OrType returns SessionSignalExpressionType
	 *     OrType.OrType_1_0 returns SessionSignalExpressionType
	 *     AndType returns SessionSignalExpressionType
	 *     AndType.AndType_1_0 returns SessionSignalExpressionType
	 *     EqualityType returns SessionSignalExpressionType
	 *     EqualityType.EqualityType_1_0 returns SessionSignalExpressionType
	 *     ComparisonType returns SessionSignalExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns SessionSignalExpressionType
	 *     PlusOrMinusType returns SessionSignalExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns SessionSignalExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns SessionSignalExpressionType
	 *     MulOrDivType returns SessionSignalExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns SessionSignalExpressionType
	 *     PrimaryType returns SessionSignalExpressionType
	 *     AtomicType returns SessionSignalExpressionType
	 *     AtomicBaseType returns SessionSignalExpressionType
	 *     SessionSignalExpressionType returns SessionSignalExpressionType
	 *
	 * Constraint:
	 *     (signal=[SignalType|ID] (op='>' | op='<' | op='=') count=INT time=INT unit=StreamTimeUnit)
	 */
	protected void sequence_SessionSignalExpressionType(ISerializationContext context, SessionSignalExpressionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns SetExpressionType
	 *     OrType returns SetExpressionType
	 *     OrType.OrType_1_0 returns SetExpressionType
	 *     AndType returns SetExpressionType
	 *     AndType.AndType_1_0 returns SetExpressionType
	 *     EqualityType returns SetExpressionType
	 *     EqualityType.EqualityType_1_0 returns SetExpressionType
	 *     ComparisonType returns SetExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns SetExpressionType
	 *     PlusOrMinusType returns SetExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns SetExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns SetExpressionType
	 *     MulOrDivType returns SetExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns SetExpressionType
	 *     PrimaryType returns SetExpressionType
	 *     AtomicType returns SetExpressionType
	 *     AtomicBaseType returns SetExpressionType
	 *     SetExpressionType returns SetExpressionType
	 *
	 * Constraint:
	 *     (args+=ExpressionType args+=ExpressionType*)?
	 */
	protected void sequence_SetExpressionType(ISerializationContext context, SetExpressionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScriptElement returns SignalType
	 *     CoreAbstractElement returns SignalType
	 *     SignalType returns SignalType
	 *
	 * Constraint:
	 *     (name=ID id=INT)
	 */
	protected void sequence_SignalType(ISerializationContext context, SignalType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SIGNAL_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SIGNAL_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SIGNAL_TYPE__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SIGNAL_TYPE__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignalTypeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSignalTypeAccess().getIdINTTerminalRuleCall_4_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns SnapshotExpressionType
	 *     OrType returns SnapshotExpressionType
	 *     OrType.OrType_1_0 returns SnapshotExpressionType
	 *     AndType returns SnapshotExpressionType
	 *     AndType.AndType_1_0 returns SnapshotExpressionType
	 *     EqualityType returns SnapshotExpressionType
	 *     EqualityType.EqualityType_1_0 returns SnapshotExpressionType
	 *     ComparisonType returns SnapshotExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns SnapshotExpressionType
	 *     PlusOrMinusType returns SnapshotExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns SnapshotExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns SnapshotExpressionType
	 *     MulOrDivType returns SnapshotExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns SnapshotExpressionType
	 *     PrimaryType returns SnapshotExpressionType
	 *     AtomicType returns SnapshotExpressionType
	 *     AtomicBaseType returns SnapshotExpressionType
	 *     SnapshotExpressionType returns SnapshotExpressionType
	 *
	 * Constraint:
	 *     (target=ExpressionType interval=INT time=StreamTimeUnit)
	 */
	protected void sequence_SnapshotExpressionType(ISerializationContext context, SnapshotExpressionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SNAPSHOT_EXPRESSION_TYPE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SNAPSHOT_EXPRESSION_TYPE__TARGET));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SNAPSHOT_EXPRESSION_TYPE__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SNAPSHOT_EXPRESSION_TYPE__INTERVAL));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SNAPSHOT_EXPRESSION_TYPE__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SNAPSHOT_EXPRESSION_TYPE__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSnapshotExpressionTypeAccess().getTargetExpressionTypeParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getSnapshotExpressionTypeAccess().getIntervalINTTerminalRuleCall_5_0(), semanticObject.getInterval());
		feeder.accept(grammarAccess.getSnapshotExpressionTypeAccess().getTimeStreamTimeUnitEnumRuleCall_6_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns SubExpressionType
	 *     OrType returns SubExpressionType
	 *     OrType.OrType_1_0 returns SubExpressionType
	 *     AndType returns SubExpressionType
	 *     AndType.AndType_1_0 returns SubExpressionType
	 *     EqualityType returns SubExpressionType
	 *     EqualityType.EqualityType_1_0 returns SubExpressionType
	 *     ComparisonType returns SubExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns SubExpressionType
	 *     PlusOrMinusType returns SubExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns SubExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns SubExpressionType
	 *     MulOrDivType returns SubExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns SubExpressionType
	 *     PrimaryType returns SubExpressionType
	 *     AtomicType returns SubExpressionType
	 *     AtomicBaseType returns SubExpressionType
	 *     SubExpressionType returns SubExpressionType
	 *
	 * Constraint:
	 *     (target=VariableValueType compare=VariableValueType)
	 */
	protected void sequence_SubExpressionType(ISerializationContext context, SubExpressionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SUB_EXPRESSION_TYPE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SUB_EXPRESSION_TYPE__TARGET));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.SUB_EXPRESSION_TYPE__COMPARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.SUB_EXPRESSION_TYPE__COMPARE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubExpressionTypeAccess().getTargetVariableValueTypeParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getSubExpressionTypeAccess().getCompareVariableValueTypeParserRuleCall_5_0(), semanticObject.getCompare());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns TickExpressionType
	 *     OrType returns TickExpressionType
	 *     OrType.OrType_1_0 returns TickExpressionType
	 *     AndType returns TickExpressionType
	 *     AndType.AndType_1_0 returns TickExpressionType
	 *     EqualityType returns TickExpressionType
	 *     EqualityType.EqualityType_1_0 returns TickExpressionType
	 *     ComparisonType returns TickExpressionType
	 *     ComparisonType.ComparisonType_1_0 returns TickExpressionType
	 *     PlusOrMinusType returns TickExpressionType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns TickExpressionType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns TickExpressionType
	 *     MulOrDivType returns TickExpressionType
	 *     MulOrDivType.MulOrDivType_1_0 returns TickExpressionType
	 *     PrimaryType returns TickExpressionType
	 *     AtomicType returns TickExpressionType
	 *     AtomicBaseType returns TickExpressionType
	 *     TickExpressionType returns TickExpressionType
	 *
	 * Constraint:
	 *     (type=INT field=INT dataType=DataType)
	 */
	protected void sequence_TickExpressionType(ISerializationContext context, TickExpressionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.TICK_EXPRESSION_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.TICK_EXPRESSION_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.TICK_EXPRESSION_TYPE__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.TICK_EXPRESSION_TYPE__FIELD));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.TICK_EXPRESSION_TYPE__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.TICK_EXPRESSION_TYPE__DATA_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTickExpressionTypeAccess().getTypeINTTerminalRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getTickExpressionTypeAccess().getFieldINTTerminalRuleCall_5_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getTickExpressionTypeAccess().getDataTypeDataTypeEnumRuleCall_7_0(), semanticObject.getDataType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptElement returns VarType
	 *     CoreAbstractElement returns VarType
	 *     VarType returns VarType
	 *
	 * Constraint:
	 *     (name=ID code=INT type=DataType expression=ExpressionType)
	 */
	protected void sequence_VarType(ISerializationContext context, VarType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VAR_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VAR_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VAR_TYPE__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VAR_TYPE__CODE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VAR_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VAR_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VAR_TYPE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VAR_TYPE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarTypeAccess().getCodeINTTerminalRuleCall_3_0(), semanticObject.getCode());
		feeder.accept(grammarAccess.getVarTypeAccess().getTypeDataTypeEnumRuleCall_5_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarTypeAccess().getExpressionExpressionTypeParserRuleCall_8_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns VariableValueExpType
	 *     OrType returns VariableValueExpType
	 *     OrType.OrType_1_0 returns VariableValueExpType
	 *     AndType returns VariableValueExpType
	 *     AndType.AndType_1_0 returns VariableValueExpType
	 *     EqualityType returns VariableValueExpType
	 *     EqualityType.EqualityType_1_0 returns VariableValueExpType
	 *     ComparisonType returns VariableValueExpType
	 *     ComparisonType.ComparisonType_1_0 returns VariableValueExpType
	 *     PlusOrMinusType returns VariableValueExpType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns VariableValueExpType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns VariableValueExpType
	 *     MulOrDivType returns VariableValueExpType
	 *     MulOrDivType.MulOrDivType_1_0 returns VariableValueExpType
	 *     PrimaryType returns VariableValueExpType
	 *     AtomicType returns VariableValueExpType
	 *     AtomicBaseType returns VariableValueExpType
	 *     VariableValueExpType returns VariableValueExpType
	 *
	 * Constraint:
	 *     expType=ExpressionType
	 */
	protected void sequence_VariableValueExpType(ISerializationContext context, VariableValueExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_EXP_TYPE__EXP_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_EXP_TYPE__EXP_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableValueExpTypeAccess().getExpTypeExpressionTypeParserRuleCall_3_0(), semanticObject.getExpType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns VariableValueRangeType
	 *     OrType returns VariableValueRangeType
	 *     OrType.OrType_1_0 returns VariableValueRangeType
	 *     AndType returns VariableValueRangeType
	 *     AndType.AndType_1_0 returns VariableValueRangeType
	 *     EqualityType returns VariableValueRangeType
	 *     EqualityType.EqualityType_1_0 returns VariableValueRangeType
	 *     ComparisonType returns VariableValueRangeType
	 *     ComparisonType.ComparisonType_1_0 returns VariableValueRangeType
	 *     PlusOrMinusType returns VariableValueRangeType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns VariableValueRangeType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns VariableValueRangeType
	 *     MulOrDivType returns VariableValueRangeType
	 *     MulOrDivType.MulOrDivType_1_0 returns VariableValueRangeType
	 *     PrimaryType returns VariableValueRangeType
	 *     AtomicType returns VariableValueRangeType
	 *     AtomicBaseType returns VariableValueRangeType
	 *     VariableValueRangeType returns VariableValueRangeType
	 *
	 * Constraint:
	 *     (targetVar=[VarType|ID] startIndex=INT endIndex=INT)
	 */
	protected void sequence_VariableValueRangeType(ISerializationContext context, VariableValueRangeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__TARGET_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__TARGET_VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__START_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__START_INDEX));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__END_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__END_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableValueRangeTypeAccess().getTargetVarVarTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XScriptPackage.Literals.VARIABLE_VALUE_RANGE_TYPE__TARGET_VAR, false));
		feeder.accept(grammarAccess.getVariableValueRangeTypeAccess().getStartIndexINTTerminalRuleCall_3_0(), semanticObject.getStartIndex());
		feeder.accept(grammarAccess.getVariableValueRangeTypeAccess().getEndIndexINTTerminalRuleCall_5_0(), semanticObject.getEndIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionType returns VariableValueType
	 *     OrType returns VariableValueType
	 *     OrType.OrType_1_0 returns VariableValueType
	 *     AndType returns VariableValueType
	 *     AndType.AndType_1_0 returns VariableValueType
	 *     EqualityType returns VariableValueType
	 *     EqualityType.EqualityType_1_0 returns VariableValueType
	 *     ComparisonType returns VariableValueType
	 *     ComparisonType.ComparisonType_1_0 returns VariableValueType
	 *     PlusOrMinusType returns VariableValueType
	 *     PlusOrMinusType.PlusType_1_0_0_0 returns VariableValueType
	 *     PlusOrMinusType.MinusType_1_0_1_0 returns VariableValueType
	 *     MulOrDivType returns VariableValueType
	 *     MulOrDivType.MulOrDivType_1_0 returns VariableValueType
	 *     PrimaryType returns VariableValueType
	 *     AtomicType returns VariableValueType
	 *     AtomicBaseType returns VariableValueType
	 *     VariableValueType returns VariableValueType
	 *
	 * Constraint:
	 *     (variable=[VarType|ID] (indexInt=INT | expType=ExpressionType))
	 */
	protected void sequence_VariableValueType(ISerializationContext context, VariableValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XAndType
	 *     XOrType returns XAndType
	 *     XOrType.XOrType_1_0 returns XAndType
	 *     XAndType returns XAndType
	 *     XAndType.XAndType_1_0 returns XAndType
	 *     XEqualityType returns XAndType
	 *     XEqualityType.XEqualityType_1_0 returns XAndType
	 *     XComparisonType returns XAndType
	 *     XComparisonType.XComparisonType_1_0 returns XAndType
	 *     XPlusOrMinusType returns XAndType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XAndType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XAndType
	 *     XMulOrDivType returns XAndType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XAndType
	 *     XPrimaryType returns XAndType
	 *
	 * Constraint:
	 *     (left=XAndType_XAndType_1_0 right=XEqualityType)
	 */
	protected void sequence_XAndType(ISerializationContext context, XAndType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XAND_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XAND_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XAND_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XAND_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXAndTypeAccess().getXAndTypeLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXAndTypeAccess().getRightXEqualityTypeParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XBoolConstantType
	 *     XOrType returns XBoolConstantType
	 *     XOrType.XOrType_1_0 returns XBoolConstantType
	 *     XAndType returns XBoolConstantType
	 *     XAndType.XAndType_1_0 returns XBoolConstantType
	 *     XEqualityType returns XBoolConstantType
	 *     XEqualityType.XEqualityType_1_0 returns XBoolConstantType
	 *     XComparisonType returns XBoolConstantType
	 *     XComparisonType.XComparisonType_1_0 returns XBoolConstantType
	 *     XPlusOrMinusType returns XBoolConstantType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XBoolConstantType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XBoolConstantType
	 *     XMulOrDivType returns XBoolConstantType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XBoolConstantType
	 *     XPrimaryType returns XBoolConstantType
	 *     XAtomicType returns XBoolConstantType
	 *     XAtomicBaseType returns XBoolConstantType
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_XAtomicBaseType(ISerializationContext context, XBoolConstantType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XDoubleConstantType
	 *     XOrType returns XDoubleConstantType
	 *     XOrType.XOrType_1_0 returns XDoubleConstantType
	 *     XAndType returns XDoubleConstantType
	 *     XAndType.XAndType_1_0 returns XDoubleConstantType
	 *     XEqualityType returns XDoubleConstantType
	 *     XEqualityType.XEqualityType_1_0 returns XDoubleConstantType
	 *     XComparisonType returns XDoubleConstantType
	 *     XComparisonType.XComparisonType_1_0 returns XDoubleConstantType
	 *     XPlusOrMinusType returns XDoubleConstantType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XDoubleConstantType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XDoubleConstantType
	 *     XMulOrDivType returns XDoubleConstantType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XDoubleConstantType
	 *     XPrimaryType returns XDoubleConstantType
	 *     XAtomicType returns XDoubleConstantType
	 *     XAtomicBaseType returns XDoubleConstantType
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_XAtomicBaseType(ISerializationContext context, XDoubleConstantType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XDOUBLE_CONSTANT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XDOUBLE_CONSTANT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXAtomicBaseTypeAccess().getValueDOUBLETerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XIntConstantType
	 *     XOrType returns XIntConstantType
	 *     XOrType.XOrType_1_0 returns XIntConstantType
	 *     XAndType returns XIntConstantType
	 *     XAndType.XAndType_1_0 returns XIntConstantType
	 *     XEqualityType returns XIntConstantType
	 *     XEqualityType.XEqualityType_1_0 returns XIntConstantType
	 *     XComparisonType returns XIntConstantType
	 *     XComparisonType.XComparisonType_1_0 returns XIntConstantType
	 *     XPlusOrMinusType returns XIntConstantType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XIntConstantType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XIntConstantType
	 *     XMulOrDivType returns XIntConstantType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XIntConstantType
	 *     XPrimaryType returns XIntConstantType
	 *     XAtomicType returns XIntConstantType
	 *     XAtomicBaseType returns XIntConstantType
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_XAtomicBaseType(ISerializationContext context, XIntConstantType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XINT_CONSTANT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XINT_CONSTANT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXAtomicBaseTypeAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XStringConstantType
	 *     XOrType returns XStringConstantType
	 *     XOrType.XOrType_1_0 returns XStringConstantType
	 *     XAndType returns XStringConstantType
	 *     XAndType.XAndType_1_0 returns XStringConstantType
	 *     XEqualityType returns XStringConstantType
	 *     XEqualityType.XEqualityType_1_0 returns XStringConstantType
	 *     XComparisonType returns XStringConstantType
	 *     XComparisonType.XComparisonType_1_0 returns XStringConstantType
	 *     XPlusOrMinusType returns XStringConstantType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XStringConstantType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XStringConstantType
	 *     XMulOrDivType returns XStringConstantType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XStringConstantType
	 *     XPrimaryType returns XStringConstantType
	 *     XAtomicType returns XStringConstantType
	 *     XAtomicBaseType returns XStringConstantType
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_XAtomicBaseType(ISerializationContext context, XStringConstantType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSTRING_CONSTANT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSTRING_CONSTANT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXAtomicBaseTypeAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptElement returns XClassType
	 *     CoreAbstractElement returns XClassType
	 *     XClassType returns XClassType
	 *
	 * Constraint:
	 *     (name=ID symbolFilter=STRING? elements+=XClassElementType*)
	 */
	protected void sequence_XClassType(ISerializationContext context, XClassType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XComparisonType
	 *     XOrType returns XComparisonType
	 *     XOrType.XOrType_1_0 returns XComparisonType
	 *     XAndType returns XComparisonType
	 *     XAndType.XAndType_1_0 returns XComparisonType
	 *     XEqualityType returns XComparisonType
	 *     XEqualityType.XEqualityType_1_0 returns XComparisonType
	 *     XComparisonType returns XComparisonType
	 *     XComparisonType.XComparisonType_1_0 returns XComparisonType
	 *     XPlusOrMinusType returns XComparisonType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XComparisonType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XComparisonType
	 *     XMulOrDivType returns XComparisonType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XComparisonType
	 *     XPrimaryType returns XComparisonType
	 *
	 * Constraint:
	 *     (left=XComparisonType_XComparisonType_1_0 (op='>=' | op='<=' | op='>' | op='<') right=XPlusOrMinusType)
	 */
	protected void sequence_XComparisonType(ISerializationContext context, XComparisonType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XDebugType
	 *     XFunctionCoreElementType returns XDebugType
	 *     XDebugType returns XDebugType
	 *     XWhileElementType returns XDebugType
	 *
	 * Constraint:
	 *     (args+=XExpressionType args+=XExpressionType*)?
	 */
	protected void sequence_XDebugType(ISerializationContext context, XDebugType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XElseIfStatementType returns XElseIfStatementType
	 *
	 * Constraint:
	 *     (expression=XExpressionType elements+=XClassFunctionElementType*)
	 */
	protected void sequence_XElseIfStatementType(ISerializationContext context, XElseIfStatementType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XElseStatementType returns XElseStatementType
	 *
	 * Constraint:
	 *     elements+=XClassFunctionElementType*
	 */
	protected void sequence_XElseStatementType(ISerializationContext context, XElseStatementType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XEqualityType
	 *     XOrType returns XEqualityType
	 *     XOrType.XOrType_1_0 returns XEqualityType
	 *     XAndType returns XEqualityType
	 *     XAndType.XAndType_1_0 returns XEqualityType
	 *     XEqualityType returns XEqualityType
	 *     XEqualityType.XEqualityType_1_0 returns XEqualityType
	 *     XComparisonType returns XEqualityType
	 *     XComparisonType.XComparisonType_1_0 returns XEqualityType
	 *     XPlusOrMinusType returns XEqualityType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XEqualityType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XEqualityType
	 *     XMulOrDivType returns XEqualityType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XEqualityType
	 *     XPrimaryType returns XEqualityType
	 *
	 * Constraint:
	 *     (left=XEqualityType_XEqualityType_1_0 (op='==' | op='!=') right=XComparisonType)
	 */
	protected void sequence_XEqualityType(ISerializationContext context, XEqualityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XFunctionCallExpType
	 *     XOrType returns XFunctionCallExpType
	 *     XOrType.XOrType_1_0 returns XFunctionCallExpType
	 *     XAndType returns XFunctionCallExpType
	 *     XAndType.XAndType_1_0 returns XFunctionCallExpType
	 *     XEqualityType returns XFunctionCallExpType
	 *     XEqualityType.XEqualityType_1_0 returns XFunctionCallExpType
	 *     XComparisonType returns XFunctionCallExpType
	 *     XComparisonType.XComparisonType_1_0 returns XFunctionCallExpType
	 *     XPlusOrMinusType returns XFunctionCallExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XFunctionCallExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XFunctionCallExpType
	 *     XMulOrDivType returns XFunctionCallExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XFunctionCallExpType
	 *     XPrimaryType returns XFunctionCallExpType
	 *     XAtomicType returns XFunctionCallExpType
	 *     XAtomicBaseType returns XFunctionCallExpType
	 *     XFunctionCallExpType returns XFunctionCallExpType
	 *
	 * Constraint:
	 *     (function=[XFunctionType|ID] parms=STRING?)
	 */
	protected void sequence_XFunctionCallExpType(ISerializationContext context, XFunctionCallExpType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XFunctionCallType
	 *     XFunctionCoreElementType returns XFunctionCallType
	 *     XFunctionCallType returns XFunctionCallType
	 *     XWhileElementType returns XFunctionCallType
	 *
	 * Constraint:
	 *     (function=[XFunctionType|ID] params=STRING?)
	 */
	protected void sequence_XFunctionCallType(ISerializationContext context, XFunctionCallType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XFunctionReturnType
	 *     XFunctionCoreElementType returns XFunctionReturnType
	 *     XFunctionReturnType returns XFunctionReturnType
	 *     XWhileElementType returns XFunctionReturnType
	 *
	 * Constraint:
	 *     returnValue=XExpressionType?
	 */
	protected void sequence_XFunctionReturnType(ISerializationContext context, XFunctionReturnType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XFunctionStartType
	 *     XFunctionCoreElementType returns XFunctionStartType
	 *     XFunctionStartType returns XFunctionStartType
	 *     XWhileElementType returns XFunctionStartType
	 *
	 * Constraint:
	 *     (function=[XFunctionType|ID] interval=INT time=StreamTimeUnit)
	 */
	protected void sequence_XFunctionStartType(ISerializationContext context, XFunctionStartType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XFUNCTION_START_TYPE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XFUNCTION_START_TYPE__FUNCTION));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XFUNCTION_START_TYPE__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XFUNCTION_START_TYPE__INTERVAL));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XFUNCTION_START_TYPE__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XFUNCTION_START_TYPE__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXFunctionStartTypeAccess().getFunctionXFunctionTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XFUNCTION_START_TYPE__FUNCTION, false));
		feeder.accept(grammarAccess.getXFunctionStartTypeAccess().getIntervalINTTerminalRuleCall_5_0(), semanticObject.getInterval());
		feeder.accept(grammarAccess.getXFunctionStartTypeAccess().getTimeStreamTimeUnitEnumRuleCall_6_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassElementType returns XFunctionType
	 *     XClassCoreElementType returns XFunctionType
	 *     XFunctionType returns XFunctionType
	 *
	 * Constraint:
	 *     (name=ID params+=[XVarType|ID]* elements+=XClassFunctionElementType*)
	 */
	protected void sequence_XFunctionType(ISerializationContext context, XFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XIfStatementType
	 *     XFunctionCoreElementType returns XIfStatementType
	 *     XIfStatementType returns XIfStatementType
	 *     XWhileElementType returns XIfStatementType
	 *
	 * Constraint:
	 *     (expression=XExpressionType elements+=XClassFunctionElementType* elseIfElements+=XElseIfStatementType* elseElement=XElseStatementType?)
	 */
	protected void sequence_XIfStatementType(ISerializationContext context, XIfStatementType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XLastSignalTriggerType
	 *     XOrType returns XLastSignalTriggerType
	 *     XOrType.XOrType_1_0 returns XLastSignalTriggerType
	 *     XAndType returns XLastSignalTriggerType
	 *     XAndType.XAndType_1_0 returns XLastSignalTriggerType
	 *     XEqualityType returns XLastSignalTriggerType
	 *     XEqualityType.XEqualityType_1_0 returns XLastSignalTriggerType
	 *     XComparisonType returns XLastSignalTriggerType
	 *     XComparisonType.XComparisonType_1_0 returns XLastSignalTriggerType
	 *     XPlusOrMinusType returns XLastSignalTriggerType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XLastSignalTriggerType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XLastSignalTriggerType
	 *     XMulOrDivType returns XLastSignalTriggerType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XLastSignalTriggerType
	 *     XPrimaryType returns XLastSignalTriggerType
	 *     XAtomicType returns XLastSignalTriggerType
	 *     XAtomicBaseType returns XLastSignalTriggerType
	 *     XLastSignalTriggerType returns XLastSignalTriggerType
	 *
	 * Constraint:
	 *     signal=[SignalType|ID]
	 */
	protected void sequence_XLastSignalTriggerType(ISerializationContext context, XLastSignalTriggerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XLAST_SIGNAL_TRIGGER_TYPE__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XLAST_SIGNAL_TRIGGER_TYPE__SIGNAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXLastSignalTriggerTypeAccess().getSignalSignalTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XLAST_SIGNAL_TRIGGER_TYPE__SIGNAL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XMulOrDivType
	 *     XOrType returns XMulOrDivType
	 *     XOrType.XOrType_1_0 returns XMulOrDivType
	 *     XAndType returns XMulOrDivType
	 *     XAndType.XAndType_1_0 returns XMulOrDivType
	 *     XEqualityType returns XMulOrDivType
	 *     XEqualityType.XEqualityType_1_0 returns XMulOrDivType
	 *     XComparisonType returns XMulOrDivType
	 *     XComparisonType.XComparisonType_1_0 returns XMulOrDivType
	 *     XPlusOrMinusType returns XMulOrDivType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XMulOrDivType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XMulOrDivType
	 *     XMulOrDivType returns XMulOrDivType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XMulOrDivType
	 *     XPrimaryType returns XMulOrDivType
	 *
	 * Constraint:
	 *     (left=XMulOrDivType_XMulOrDivType_1_0 (op='*' | op='/') right=XPrimaryType)
	 */
	protected void sequence_XMulOrDivType(ISerializationContext context, XMulOrDivType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XOrType
	 *     XOrType returns XOrType
	 *     XOrType.XOrType_1_0 returns XOrType
	 *     XAndType returns XOrType
	 *     XAndType.XAndType_1_0 returns XOrType
	 *     XEqualityType returns XOrType
	 *     XEqualityType.XEqualityType_1_0 returns XOrType
	 *     XComparisonType returns XOrType
	 *     XComparisonType.XComparisonType_1_0 returns XOrType
	 *     XPlusOrMinusType returns XOrType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XOrType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XOrType
	 *     XMulOrDivType returns XOrType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XOrType
	 *     XPrimaryType returns XOrType
	 *
	 * Constraint:
	 *     (left=XOrType_XOrType_1_0 right=XAndType)
	 */
	protected void sequence_XOrType(ISerializationContext context, XOrType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XOR_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XOR_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XOR_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XOR_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXOrTypeAccess().getXOrTypeLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXOrTypeAccess().getRightXAndTypeParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XPercentChangeExpType
	 *     XOrType returns XPercentChangeExpType
	 *     XOrType.XOrType_1_0 returns XPercentChangeExpType
	 *     XAndType returns XPercentChangeExpType
	 *     XAndType.XAndType_1_0 returns XPercentChangeExpType
	 *     XEqualityType returns XPercentChangeExpType
	 *     XEqualityType.XEqualityType_1_0 returns XPercentChangeExpType
	 *     XComparisonType returns XPercentChangeExpType
	 *     XComparisonType.XComparisonType_1_0 returns XPercentChangeExpType
	 *     XPlusOrMinusType returns XPercentChangeExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XPercentChangeExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XPercentChangeExpType
	 *     XMulOrDivType returns XPercentChangeExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XPercentChangeExpType
	 *     XPrimaryType returns XPercentChangeExpType
	 *     XAtomicType returns XPercentChangeExpType
	 *     XAtomicBaseType returns XPercentChangeExpType
	 *     XPercentChangeExpType returns XPercentChangeExpType
	 *
	 * Constraint:
	 *     (value1=XExpressionType value2=XExpressionType)
	 */
	protected void sequence_XPercentChangeExpType(ISerializationContext context, XPercentChangeExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XPERCENT_CHANGE_EXP_TYPE__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XPERCENT_CHANGE_EXP_TYPE__VALUE1));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XPERCENT_CHANGE_EXP_TYPE__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XPERCENT_CHANGE_EXP_TYPE__VALUE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXPercentChangeExpTypeAccess().getValue1XExpressionTypeParserRuleCall_3_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getXPercentChangeExpTypeAccess().getValue2XExpressionTypeParserRuleCall_5_0(), semanticObject.getValue2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XMinusType
	 *     XOrType returns XMinusType
	 *     XOrType.XOrType_1_0 returns XMinusType
	 *     XAndType returns XMinusType
	 *     XAndType.XAndType_1_0 returns XMinusType
	 *     XEqualityType returns XMinusType
	 *     XEqualityType.XEqualityType_1_0 returns XMinusType
	 *     XComparisonType returns XMinusType
	 *     XComparisonType.XComparisonType_1_0 returns XMinusType
	 *     XPlusOrMinusType returns XMinusType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XMinusType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XMinusType
	 *     XMulOrDivType returns XMinusType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XMinusType
	 *     XPrimaryType returns XMinusType
	 *
	 * Constraint:
	 *     (left=XPlusOrMinusType_XMinusType_1_0_1_0 right=XMulOrDivType)
	 */
	protected void sequence_XPlusOrMinusType(ISerializationContext context, XMinusType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XMINUS_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XMINUS_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XMINUS_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XMINUS_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXPlusOrMinusTypeAccess().getXMinusTypeLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXPlusOrMinusTypeAccess().getRightXMulOrDivTypeParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XPlusType
	 *     XOrType returns XPlusType
	 *     XOrType.XOrType_1_0 returns XPlusType
	 *     XAndType returns XPlusType
	 *     XAndType.XAndType_1_0 returns XPlusType
	 *     XEqualityType returns XPlusType
	 *     XEqualityType.XEqualityType_1_0 returns XPlusType
	 *     XComparisonType returns XPlusType
	 *     XComparisonType.XComparisonType_1_0 returns XPlusType
	 *     XPlusOrMinusType returns XPlusType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XPlusType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XPlusType
	 *     XMulOrDivType returns XPlusType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XPlusType
	 *     XPrimaryType returns XPlusType
	 *
	 * Constraint:
	 *     (left=XPlusOrMinusType_XPlusType_1_0_0_0 right=XMulOrDivType)
	 */
	protected void sequence_XPlusOrMinusType(ISerializationContext context, XPlusType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XPLUS_TYPE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XPLUS_TYPE__LEFT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XPLUS_TYPE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XPLUS_TYPE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXPlusOrMinusTypeAccess().getXPlusTypeLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXPlusOrMinusTypeAccess().getRightXMulOrDivTypeParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XNotType
	 *     XOrType returns XNotType
	 *     XOrType.XOrType_1_0 returns XNotType
	 *     XAndType returns XNotType
	 *     XAndType.XAndType_1_0 returns XNotType
	 *     XEqualityType returns XNotType
	 *     XEqualityType.XEqualityType_1_0 returns XNotType
	 *     XComparisonType returns XNotType
	 *     XComparisonType.XComparisonType_1_0 returns XNotType
	 *     XPlusOrMinusType returns XNotType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XNotType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XNotType
	 *     XMulOrDivType returns XNotType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XNotType
	 *     XPrimaryType returns XNotType
	 *
	 * Constraint:
	 *     expression=XPrimaryType
	 */
	protected void sequence_XPrimaryType(ISerializationContext context, XNotType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XNOT_TYPE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XNOT_TYPE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXPrimaryTypeAccess().getExpressionXPrimaryTypeParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XQueryFilterType returns XQueryFilterValueCompareType
	 *     XQueryFilterValueCompareType returns XQueryFilterValueCompareType
	 *
	 * Constraint:
	 *     (value1=XValueType value2=XValueType function=XQueryValueCompareFunction operator=XStreamOperator criteria=STRING)
	 */
	protected void sequence_XQueryFilterValueCompareType(ISerializationContext context, XQueryFilterValueCompareType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_COMPARE_TYPE__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_COMPARE_TYPE__VALUE1));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_COMPARE_TYPE__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_COMPARE_TYPE__VALUE2));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_COMPARE_TYPE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_COMPARE_TYPE__FUNCTION));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__CRITERIA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__CRITERIA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXQueryFilterValueCompareTypeAccess().getValue1XValueTypeParserRuleCall_2_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getXQueryFilterValueCompareTypeAccess().getValue2XValueTypeParserRuleCall_4_0(), semanticObject.getValue2());
		feeder.accept(grammarAccess.getXQueryFilterValueCompareTypeAccess().getFunctionXQueryValueCompareFunctionEnumRuleCall_6_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getXQueryFilterValueCompareTypeAccess().getOperatorXStreamOperatorEnumRuleCall_8_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXQueryFilterValueCompareTypeAccess().getCriteriaSTRINGTerminalRuleCall_10_0(), semanticObject.getCriteria());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XQueryFilterType returns XQueryFilterValueType
	 *     XQueryFilterValueType returns XQueryFilterValueType
	 *
	 * Constraint:
	 *     (value=XValueType operator=XStreamOperator criteria=STRING)
	 */
	protected void sequence_XQueryFilterValueType(ISerializationContext context, XQueryFilterValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_VALUE_TYPE__VALUE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__CRITERIA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XQUERY_FILTER_TYPE__CRITERIA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXQueryFilterValueTypeAccess().getValueXValueTypeParserRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getXQueryFilterValueTypeAccess().getOperatorXStreamOperatorEnumRuleCall_5_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXQueryFilterValueTypeAccess().getCriteriaSTRINGTerminalRuleCall_7_0(), semanticObject.getCriteria());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScriptElement returns XQueryType
	 *     CoreAbstractElement returns XQueryType
	 *     XQueryType returns XQueryType
	 *
	 * Constraint:
	 *     (name=ID filters+=XQueryFilterType*)
	 */
	protected void sequence_XQueryType(ISerializationContext context, XQueryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XRocExpType
	 *     XOrType returns XRocExpType
	 *     XOrType.XOrType_1_0 returns XRocExpType
	 *     XAndType returns XRocExpType
	 *     XAndType.XAndType_1_0 returns XRocExpType
	 *     XEqualityType returns XRocExpType
	 *     XEqualityType.XEqualityType_1_0 returns XRocExpType
	 *     XComparisonType returns XRocExpType
	 *     XComparisonType.XComparisonType_1_0 returns XRocExpType
	 *     XPlusOrMinusType returns XRocExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XRocExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XRocExpType
	 *     XMulOrDivType returns XRocExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XRocExpType
	 *     XPrimaryType returns XRocExpType
	 *     XAtomicType returns XRocExpType
	 *     XAtomicBaseType returns XRocExpType
	 *     XRocExpType returns XRocExpType
	 *
	 * Constraint:
	 *     (value1=XExpressionType value2=XExpressionType)
	 */
	protected void sequence_XRocExpType(ISerializationContext context, XRocExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XROC_EXP_TYPE__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XROC_EXP_TYPE__VALUE1));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XROC_EXP_TYPE__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XROC_EXP_TYPE__VALUE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXRocExpTypeAccess().getValue1XExpressionTypeParserRuleCall_3_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getXRocExpTypeAccess().getValue2XExpressionTypeParserRuleCall_5_0(), semanticObject.getValue2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XScript returns XScript
	 *
	 * Constraint:
	 *     elements+=ScriptElement+
	 */
	protected void sequence_XScript(ISerializationContext context, XScript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XSetVarType
	 *     XFunctionCoreElementType returns XSetVarType
	 *     XSetVarType returns XSetVarType
	 *     XWhileElementType returns XSetVarType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] value=XExpressionType)
	 */
	protected void sequence_XSetVarType(ISerializationContext context, XSetVarType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSET_VAR_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSET_VAR_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSET_VAR_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSET_VAR_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSetVarTypeAccess().getVarVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSET_VAR_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXSetVarTypeAccess().getValueXExpressionTypeParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XSignalListenerType
	 *     XFunctionCoreElementType returns XSignalListenerType
	 *     XSignalListenerType returns XSignalListenerType
	 *     XWhileElementType returns XSignalListenerType
	 *
	 * Constraint:
	 *     (signalType=[SignalType|ID] function=[XFunctionType|ID])
	 */
	protected void sequence_XSignalListenerType(ISerializationContext context, XSignalListenerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSIGNAL_LISTENER_TYPE__SIGNAL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSIGNAL_LISTENER_TYPE__SIGNAL_TYPE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSIGNAL_LISTENER_TYPE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSIGNAL_LISTENER_TYPE__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSignalListenerTypeAccess().getSignalTypeSignalTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSIGNAL_LISTENER_TYPE__SIGNAL_TYPE, false));
		feeder.accept(grammarAccess.getXSignalListenerTypeAccess().getFunctionXFunctionTypeIDTerminalRuleCall_5_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSIGNAL_LISTENER_TYPE__FUNCTION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XSignalTriggerCountType
	 *     XOrType returns XSignalTriggerCountType
	 *     XOrType.XOrType_1_0 returns XSignalTriggerCountType
	 *     XAndType returns XSignalTriggerCountType
	 *     XAndType.XAndType_1_0 returns XSignalTriggerCountType
	 *     XEqualityType returns XSignalTriggerCountType
	 *     XEqualityType.XEqualityType_1_0 returns XSignalTriggerCountType
	 *     XComparisonType returns XSignalTriggerCountType
	 *     XComparisonType.XComparisonType_1_0 returns XSignalTriggerCountType
	 *     XPlusOrMinusType returns XSignalTriggerCountType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XSignalTriggerCountType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XSignalTriggerCountType
	 *     XMulOrDivType returns XSignalTriggerCountType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XSignalTriggerCountType
	 *     XPrimaryType returns XSignalTriggerCountType
	 *     XAtomicType returns XSignalTriggerCountType
	 *     XAtomicBaseType returns XSignalTriggerCountType
	 *     XSignalTriggerCountType returns XSignalTriggerCountType
	 *
	 * Constraint:
	 *     (signal=[SignalType|ID] lookback=INT)
	 */
	protected void sequence_XSignalTriggerCountType(ISerializationContext context, XSignalTriggerCountType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSIGNAL_TRIGGER_COUNT_TYPE__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSIGNAL_TRIGGER_COUNT_TYPE__SIGNAL));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSIGNAL_TRIGGER_COUNT_TYPE__LOOKBACK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSIGNAL_TRIGGER_COUNT_TYPE__LOOKBACK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSignalTriggerCountTypeAccess().getSignalSignalTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSIGNAL_TRIGGER_COUNT_TYPE__SIGNAL, false));
		feeder.accept(grammarAccess.getXSignalTriggerCountTypeAccess().getLookbackINTTerminalRuleCall_5_0(), semanticObject.getLookback());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XSignalTriggerType
	 *     XFunctionCoreElementType returns XSignalTriggerType
	 *     XSignalTriggerType returns XSignalTriggerType
	 *     XWhileElementType returns XSignalTriggerType
	 *
	 * Constraint:
	 *     signal=[SignalType|ID]
	 */
	protected void sequence_XSignalTriggerType(ISerializationContext context, XSignalTriggerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSIGNAL_TRIGGER_TYPE__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSIGNAL_TRIGGER_TYPE__SIGNAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSignalTriggerTypeAccess().getSignalSignalTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSIGNAL_TRIGGER_TYPE__SIGNAL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XSleepType
	 *     XFunctionCoreElementType returns XSleepType
	 *     XWhileElementType returns XSleepType
	 *     XSleepType returns XSleepType
	 *
	 * Constraint:
	 *     (interval=INT unit=StreamTimeUnit)
	 */
	protected void sequence_XSleepType(ISerializationContext context, XSleepType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSLEEP_TYPE__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSLEEP_TYPE__INTERVAL));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSLEEP_TYPE__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSLEEP_TYPE__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSleepTypeAccess().getIntervalINTTerminalRuleCall_3_0(), semanticObject.getInterval());
		feeder.accept(grammarAccess.getXSleepTypeAccess().getUnitStreamTimeUnitEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XSlrAvgExpType
	 *     XOrType returns XSlrAvgExpType
	 *     XOrType.XOrType_1_0 returns XSlrAvgExpType
	 *     XAndType returns XSlrAvgExpType
	 *     XAndType.XAndType_1_0 returns XSlrAvgExpType
	 *     XEqualityType returns XSlrAvgExpType
	 *     XEqualityType.XEqualityType_1_0 returns XSlrAvgExpType
	 *     XComparisonType returns XSlrAvgExpType
	 *     XComparisonType.XComparisonType_1_0 returns XSlrAvgExpType
	 *     XPlusOrMinusType returns XSlrAvgExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XSlrAvgExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XSlrAvgExpType
	 *     XMulOrDivType returns XSlrAvgExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XSlrAvgExpType
	 *     XPrimaryType returns XSlrAvgExpType
	 *     XAtomicType returns XSlrAvgExpType
	 *     XAtomicBaseType returns XSlrAvgExpType
	 *     XSlrAvgExpType returns XSlrAvgExpType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] startValue=XExpressionType endValue=XExpressionType)
	 */
	protected void sequence_XSlrAvgExpType(ISerializationContext context, XSlrAvgExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__START_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__START_VALUE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__END_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__END_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSlrAvgExpTypeAccess().getVarVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSLR_AVG_EXP_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXSlrAvgExpTypeAccess().getStartValueXExpressionTypeParserRuleCall_5_0(), semanticObject.getStartValue());
		feeder.accept(grammarAccess.getXSlrAvgExpTypeAccess().getEndValueXExpressionTypeParserRuleCall_7_0(), semanticObject.getEndValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XStreamVarListenerType
	 *     XFunctionCoreElementType returns XStreamVarListenerType
	 *     XStreamVarListenerType returns XStreamVarListenerType
	 *     XWhileElementType returns XStreamVarListenerType
	 *
	 * Constraint:
	 *     (column=[VarType|ID] function=[XFunctionType|ID])
	 */
	protected void sequence_XStreamVarListenerType(ISerializationContext context, XStreamVarListenerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_LISTENER_TYPE__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_LISTENER_TYPE__COLUMN));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_LISTENER_TYPE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_LISTENER_TYPE__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXStreamVarListenerTypeAccess().getColumnVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSTREAM_VAR_LISTENER_TYPE__COLUMN, false));
		feeder.accept(grammarAccess.getXStreamVarListenerTypeAccess().getFunctionXFunctionTypeIDTerminalRuleCall_5_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSTREAM_VAR_LISTENER_TYPE__FUNCTION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XStreamVarValueExpType
	 *     XOrType returns XStreamVarValueExpType
	 *     XOrType.XOrType_1_0 returns XStreamVarValueExpType
	 *     XAndType returns XStreamVarValueExpType
	 *     XAndType.XAndType_1_0 returns XStreamVarValueExpType
	 *     XEqualityType returns XStreamVarValueExpType
	 *     XEqualityType.XEqualityType_1_0 returns XStreamVarValueExpType
	 *     XComparisonType returns XStreamVarValueExpType
	 *     XComparisonType.XComparisonType_1_0 returns XStreamVarValueExpType
	 *     XPlusOrMinusType returns XStreamVarValueExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XStreamVarValueExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XStreamVarValueExpType
	 *     XMulOrDivType returns XStreamVarValueExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XStreamVarValueExpType
	 *     XPrimaryType returns XStreamVarValueExpType
	 *     XAtomicType returns XStreamVarValueExpType
	 *     XAtomicBaseType returns XStreamVarValueExpType
	 *     XStreamVarValueExpType returns XStreamVarValueExpType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] expressionValue=XExpressionType)
	 */
	protected void sequence_XStreamVarValueExpType(ISerializationContext context, XStreamVarValueExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_VALUE_EXP_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_VALUE_EXP_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_VALUE_EXP_TYPE__EXPRESSION_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSTREAM_VAR_VALUE_EXP_TYPE__EXPRESSION_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXStreamVarValueExpTypeAccess().getVarVarTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XScriptPackage.Literals.XSTREAM_VAR_VALUE_EXP_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXStreamVarValueExpTypeAccess().getExpressionValueXExpressionTypeParserRuleCall_2_1_0(), semanticObject.getExpressionValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XStreamWrapperExpType
	 *     XOrType returns XStreamWrapperExpType
	 *     XOrType.XOrType_1_0 returns XStreamWrapperExpType
	 *     XAndType returns XStreamWrapperExpType
	 *     XAndType.XAndType_1_0 returns XStreamWrapperExpType
	 *     XEqualityType returns XStreamWrapperExpType
	 *     XEqualityType.XEqualityType_1_0 returns XStreamWrapperExpType
	 *     XComparisonType returns XStreamWrapperExpType
	 *     XComparisonType.XComparisonType_1_0 returns XStreamWrapperExpType
	 *     XPlusOrMinusType returns XStreamWrapperExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XStreamWrapperExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XStreamWrapperExpType
	 *     XMulOrDivType returns XStreamWrapperExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XStreamWrapperExpType
	 *     XPrimaryType returns XStreamWrapperExpType
	 *     XAtomicType returns XStreamWrapperExpType
	 *     XAtomicBaseType returns XStreamWrapperExpType
	 *     XStreamWrapperExpType returns XStreamWrapperExpType
	 *
	 * Constraint:
	 *     wrapperExp=ExpressionType
	 */
	protected void sequence_XStreamWrapperExpType(ISerializationContext context, XStreamWrapperExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSTREAM_WRAPPER_EXP_TYPE__WRAPPER_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSTREAM_WRAPPER_EXP_TYPE__WRAPPER_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXStreamWrapperExpTypeAccess().getWrapperExpExpressionTypeParserRuleCall_3_0(), semanticObject.getWrapperExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XSubExpType
	 *     XOrType returns XSubExpType
	 *     XOrType.XOrType_1_0 returns XSubExpType
	 *     XAndType returns XSubExpType
	 *     XAndType.XAndType_1_0 returns XSubExpType
	 *     XEqualityType returns XSubExpType
	 *     XEqualityType.XEqualityType_1_0 returns XSubExpType
	 *     XComparisonType returns XSubExpType
	 *     XComparisonType.XComparisonType_1_0 returns XSubExpType
	 *     XPlusOrMinusType returns XSubExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XSubExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XSubExpType
	 *     XMulOrDivType returns XSubExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XSubExpType
	 *     XPrimaryType returns XSubExpType
	 *     XAtomicType returns XSubExpType
	 *     XAtomicBaseType returns XSubExpType
	 *     XSubExpType returns XSubExpType
	 *
	 * Constraint:
	 *     (value1=XExpressionType value2=XExpressionType)
	 */
	protected void sequence_XSubExpType(ISerializationContext context, XSubExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSUB_EXP_TYPE__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSUB_EXP_TYPE__VALUE1));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XSUB_EXP_TYPE__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XSUB_EXP_TYPE__VALUE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXSubExpTypeAccess().getValue1XExpressionTypeParserRuleCall_3_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getXSubExpTypeAccess().getValue2XExpressionTypeParserRuleCall_5_0(), semanticObject.getValue2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XTimeRange returns XTimeRangeRelative
	 *     XTimeRangeRelative returns XTimeRangeRelative
	 *
	 * Constraint:
	 *     (unit=StreamTimeUnit value=INT)
	 */
	protected void sequence_XTimeRangeRelative(ISerializationContext context, XTimeRangeRelative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XTIME_RANGE_RELATIVE__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XTIME_RANGE_RELATIVE__UNIT));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XTIME_RANGE_RELATIVE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XTIME_RANGE_RELATIVE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXTimeRangeRelativeAccess().getUnitStreamTimeUnitEnumRuleCall_3_0(), semanticObject.getUnit());
		feeder.accept(grammarAccess.getXTimeRangeRelativeAccess().getValueINTTerminalRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XValueType returns XValueHistoricalSignalCountType
	 *     XValueHistoricalSignalCountType returns XValueHistoricalSignalCountType
	 *
	 * Constraint:
	 *     (signal=[SignalType|ID] days=INT)
	 */
	protected void sequence_XValueHistoricalSignalCountType(ISerializationContext context, XValueHistoricalSignalCountType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_SIGNAL_COUNT_TYPE__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_SIGNAL_COUNT_TYPE__SIGNAL));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_SIGNAL_COUNT_TYPE__DAYS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_SIGNAL_COUNT_TYPE__DAYS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXValueHistoricalSignalCountTypeAccess().getSignalSignalTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVALUE_HISTORICAL_SIGNAL_COUNT_TYPE__SIGNAL, false));
		feeder.accept(grammarAccess.getXValueHistoricalSignalCountTypeAccess().getDaysINTTerminalRuleCall_5_0(), semanticObject.getDays());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XValueHistoricalVarAggType returns XValueHistoricalVarAggType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] function=XValueVarHistoricalAggFunction days=INT)
	 */
	protected void sequence_XValueHistoricalVarAggType(ISerializationContext context, XValueHistoricalVarAggType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__FUNCTION));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__DAYS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__DAYS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXValueHistoricalVarAggTypeAccess().getVarVarTypeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVALUE_HISTORICAL_VAR_AGG_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXValueHistoricalVarAggTypeAccess().getFunctionXValueVarHistoricalAggFunctionEnumRuleCall_4_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getXValueHistoricalVarAggTypeAccess().getDaysINTTerminalRuleCall_6_0(), semanticObject.getDays());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XValueType returns XValueSessionSignalCountType
	 *     XValueSessionSignalCountType returns XValueSessionSignalCountType
	 *
	 * Constraint:
	 *     (signal=[SignalType|ID] timeRange=XTimeRange value=INT)
	 */
	protected void sequence_XValueSessionSignalCountType(ISerializationContext context, XValueSessionSignalCountType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__SIGNAL));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__TIME_RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__TIME_RANGE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXValueSessionSignalCountTypeAccess().getSignalSignalTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVALUE_SESSION_SIGNAL_COUNT_TYPE__SIGNAL, false));
		feeder.accept(grammarAccess.getXValueSessionSignalCountTypeAccess().getTimeRangeXTimeRangeParserRuleCall_5_0(), semanticObject.getTimeRange());
		feeder.accept(grammarAccess.getXValueSessionSignalCountTypeAccess().getValueINTTerminalRuleCall_7_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XValueType returns XValueSessionVarAggType
	 *     XValueSessionVarAggType returns XValueSessionVarAggType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] function=XValueVarSessionAggFunction range=XTimeRange)
	 */
	protected void sequence_XValueSessionVarAggType(ISerializationContext context, XValueSessionVarAggType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__FUNCTION));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXValueSessionVarAggTypeAccess().getVarVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVALUE_SESSION_VAR_AGG_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXValueSessionVarAggTypeAccess().getFunctionXValueVarSessionAggFunctionEnumRuleCall_5_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getXValueSessionVarAggTypeAccess().getRangeXTimeRangeParserRuleCall_7_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XValueType returns XValueSessionVarValueType
	 *     XValueSessionVarValueType returns XValueSessionVarValueType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] index=INT)
	 */
	protected void sequence_XValueSessionVarValueType(ISerializationContext context, XValueSessionVarValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_VALUE_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_VALUE_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_VALUE_TYPE__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVALUE_SESSION_VAR_VALUE_TYPE__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXValueSessionVarValueTypeAccess().getVarVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVALUE_SESSION_VAR_VALUE_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXValueSessionVarValueTypeAccess().getIndexINTTerminalRuleCall_5_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XVarCompareStreakType
	 *     XOrType returns XVarCompareStreakType
	 *     XOrType.XOrType_1_0 returns XVarCompareStreakType
	 *     XAndType returns XVarCompareStreakType
	 *     XAndType.XAndType_1_0 returns XVarCompareStreakType
	 *     XEqualityType returns XVarCompareStreakType
	 *     XEqualityType.XEqualityType_1_0 returns XVarCompareStreakType
	 *     XComparisonType returns XVarCompareStreakType
	 *     XComparisonType.XComparisonType_1_0 returns XVarCompareStreakType
	 *     XPlusOrMinusType returns XVarCompareStreakType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XVarCompareStreakType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XVarCompareStreakType
	 *     XMulOrDivType returns XVarCompareStreakType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XVarCompareStreakType
	 *     XPrimaryType returns XVarCompareStreakType
	 *     XAtomicType returns XVarCompareStreakType
	 *     XAtomicBaseType returns XVarCompareStreakType
	 *     XVarCompareStreakType returns XVarCompareStreakType
	 *
	 * Constraint:
	 *     (
	 *         targetVar=[VarType|ID] 
	 *         compareVar=[VarType|ID] 
	 *         (direction='bwd' | direction='fwd') 
	 *         startIndexExp=XExpressionType 
	 *         (function='sum' | function='diff' | function='value' | function='variance') 
	 *         (op='<' | op='>' | op='=') 
	 *         test=DOUBLE
	 *     )
	 */
	protected void sequence_XVarCompareStreakType(ISerializationContext context, XVarCompareStreakType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XVarDecrementType
	 *     XFunctionCoreElementType returns XVarDecrementType
	 *     XVarDecrementType returns XVarDecrementType
	 *     XWhileElementType returns XVarDecrementType
	 *
	 * Constraint:
	 *     var=[XVarType|ID]
	 */
	protected void sequence_XVarDecrementType(ISerializationContext context, XVarDecrementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVAR_DECREMENT_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVAR_DECREMENT_TYPE__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXVarDecrementTypeAccess().getVarXVarTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVAR_DECREMENT_TYPE__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XVarExpType
	 *     XOrType returns XVarExpType
	 *     XOrType.XOrType_1_0 returns XVarExpType
	 *     XAndType returns XVarExpType
	 *     XAndType.XAndType_1_0 returns XVarExpType
	 *     XEqualityType returns XVarExpType
	 *     XEqualityType.XEqualityType_1_0 returns XVarExpType
	 *     XComparisonType returns XVarExpType
	 *     XComparisonType.XComparisonType_1_0 returns XVarExpType
	 *     XPlusOrMinusType returns XVarExpType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XVarExpType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XVarExpType
	 *     XMulOrDivType returns XVarExpType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XVarExpType
	 *     XPrimaryType returns XVarExpType
	 *     XAtomicType returns XVarExpType
	 *     XAtomicBaseType returns XVarExpType
	 *     XVarExpType returns XVarExpType
	 *
	 * Constraint:
	 *     expVar=[XVarType|ID]
	 */
	protected void sequence_XVarExpType(ISerializationContext context, XVarExpType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVAR_EXP_TYPE__EXP_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVAR_EXP_TYPE__EXP_VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXVarExpTypeAccess().getExpVarXVarTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVAR_EXP_TYPE__EXP_VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XVarIncrementType
	 *     XFunctionCoreElementType returns XVarIncrementType
	 *     XVarIncrementType returns XVarIncrementType
	 *     XWhileElementType returns XVarIncrementType
	 *
	 * Constraint:
	 *     var=[XVarType|ID]
	 */
	protected void sequence_XVarIncrementType(ISerializationContext context, XVarIncrementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVAR_INCREMENT_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVAR_INCREMENT_TYPE__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXVarIncrementTypeAccess().getVarXVarTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVAR_INCREMENT_TYPE__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XVarSetterType
	 *     XFunctionCoreElementType returns XVarSetterType
	 *     XVarSetterType returns XVarSetterType
	 *     XWhileElementType returns XVarSetterType
	 *
	 * Constraint:
	 *     (var=[XVarType|ID] exp=XExpressionType)
	 */
	protected void sequence_XVarSetterType(ISerializationContext context, XVarSetterType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVAR_SETTER_TYPE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVAR_SETTER_TYPE__VAR));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVAR_SETTER_TYPE__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVAR_SETTER_TYPE__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXVarSetterTypeAccess().getVarXVarTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVAR_SETTER_TYPE__VAR, false));
		feeder.accept(grammarAccess.getXVarSetterTypeAccess().getExpXExpressionTypeParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XVarStreakCompareType returns XVarStreakCompareType
	 *
	 * Constraint:
	 *     ((function='sum' | function='diff') offset=INT (op='<' | op='>' | op='=') test=DOUBLE)
	 */
	protected void sequence_XVarStreakCompareType(ISerializationContext context, XVarStreakCompareType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XVarStreakType
	 *     XOrType returns XVarStreakType
	 *     XOrType.XOrType_1_0 returns XVarStreakType
	 *     XAndType returns XVarStreakType
	 *     XAndType.XAndType_1_0 returns XVarStreakType
	 *     XEqualityType returns XVarStreakType
	 *     XEqualityType.XEqualityType_1_0 returns XVarStreakType
	 *     XComparisonType returns XVarStreakType
	 *     XComparisonType.XComparisonType_1_0 returns XVarStreakType
	 *     XPlusOrMinusType returns XVarStreakType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XVarStreakType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XVarStreakType
	 *     XMulOrDivType returns XVarStreakType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XVarStreakType
	 *     XPrimaryType returns XVarStreakType
	 *     XAtomicType returns XVarStreakType
	 *     XAtomicBaseType returns XVarStreakType
	 *     XVarStreakType returns XVarStreakType
	 *
	 * Constraint:
	 *     (var=[VarType|ID] (direction='bwd' | direction='fwd') startIndexExp=XExpressionType (compare=XVarStreakCompareType | value=XVarStreakValueType))
	 */
	protected void sequence_XVarStreakType(ISerializationContext context, XVarStreakType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XVarStreakValueType returns XVarStreakValueType
	 *
	 * Constraint:
	 *     ((op='<' | op='>' | op='=') test=DOUBLE)
	 */
	protected void sequence_XVarStreakValueType(ISerializationContext context, XVarStreakValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassElementType returns XVarType
	 *     XClassCoreElementType returns XVarType
	 *     XVarType returns XVarType
	 *     XClassFunctionElementType returns XVarType
	 *     XFunctionCoreElementType returns XVarType
	 *     XWhileElementType returns XVarType
	 *
	 * Constraint:
	 *     (name=ID exp=XExpressionType?)
	 */
	protected void sequence_XVarType(ISerializationContext context, XVarType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XVarianceAverageType
	 *     XOrType returns XVarianceAverageType
	 *     XOrType.XOrType_1_0 returns XVarianceAverageType
	 *     XAndType returns XVarianceAverageType
	 *     XAndType.XAndType_1_0 returns XVarianceAverageType
	 *     XEqualityType returns XVarianceAverageType
	 *     XEqualityType.XEqualityType_1_0 returns XVarianceAverageType
	 *     XComparisonType returns XVarianceAverageType
	 *     XComparisonType.XComparisonType_1_0 returns XVarianceAverageType
	 *     XPlusOrMinusType returns XVarianceAverageType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XVarianceAverageType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XVarianceAverageType
	 *     XMulOrDivType returns XVarianceAverageType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XVarianceAverageType
	 *     XPrimaryType returns XVarianceAverageType
	 *     XAtomicType returns XVarianceAverageType
	 *     XAtomicBaseType returns XVarianceAverageType
	 *     XVarianceAverageType returns XVarianceAverageType
	 *
	 * Constraint:
	 *     (target=[VarType|ID] compare=[VarType|ID] start=XExpressionType end=XExpressionType)
	 */
	protected void sequence_XVarianceAverageType(ISerializationContext context, XVarianceAverageType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__TARGET));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__COMPARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__COMPARE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__START));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXVarianceAverageTypeAccess().getTargetVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__TARGET, false));
		feeder.accept(grammarAccess.getXVarianceAverageTypeAccess().getCompareVarTypeIDTerminalRuleCall_5_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVARIANCE_AVERAGE_TYPE__COMPARE, false));
		feeder.accept(grammarAccess.getXVarianceAverageTypeAccess().getStartXExpressionTypeParserRuleCall_7_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getXVarianceAverageTypeAccess().getEndXExpressionTypeParserRuleCall_9_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XExpressionType returns XVarianceMaxType
	 *     XOrType returns XVarianceMaxType
	 *     XOrType.XOrType_1_0 returns XVarianceMaxType
	 *     XAndType returns XVarianceMaxType
	 *     XAndType.XAndType_1_0 returns XVarianceMaxType
	 *     XEqualityType returns XVarianceMaxType
	 *     XEqualityType.XEqualityType_1_0 returns XVarianceMaxType
	 *     XComparisonType returns XVarianceMaxType
	 *     XComparisonType.XComparisonType_1_0 returns XVarianceMaxType
	 *     XPlusOrMinusType returns XVarianceMaxType
	 *     XPlusOrMinusType.XPlusType_1_0_0_0 returns XVarianceMaxType
	 *     XPlusOrMinusType.XMinusType_1_0_1_0 returns XVarianceMaxType
	 *     XMulOrDivType returns XVarianceMaxType
	 *     XMulOrDivType.XMulOrDivType_1_0 returns XVarianceMaxType
	 *     XPrimaryType returns XVarianceMaxType
	 *     XAtomicType returns XVarianceMaxType
	 *     XAtomicBaseType returns XVarianceMaxType
	 *     XVarianceMaxType returns XVarianceMaxType
	 *
	 * Constraint:
	 *     (target=[VarType|ID] compare=[VarType|ID] start=XExpressionType end=XExpressionType)
	 */
	protected void sequence_XVarianceMaxType(ISerializationContext context, XVarianceMaxType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__TARGET));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__COMPARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__COMPARE));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__START));
			if (transientValues.isValueTransient(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XScriptPackage.Literals.XVARIANCE_MAX_TYPE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXVarianceMaxTypeAccess().getTargetVarTypeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVARIANCE_MAX_TYPE__TARGET, false));
		feeder.accept(grammarAccess.getXVarianceMaxTypeAccess().getCompareVarTypeIDTerminalRuleCall_5_0_1(), semanticObject.eGet(XScriptPackage.Literals.XVARIANCE_MAX_TYPE__COMPARE, false));
		feeder.accept(grammarAccess.getXVarianceMaxTypeAccess().getStartXExpressionTypeParserRuleCall_7_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getXVarianceMaxTypeAccess().getEndXExpressionTypeParserRuleCall_9_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XWhileElementType returns XWhileBreakType
	 *     XWhileBreakType returns XWhileBreakType
	 *
	 * Constraint:
	 *     {XWhileBreakType}
	 */
	protected void sequence_XWhileBreakType(ISerializationContext context, XWhileBreakType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XClassFunctionElementType returns XWhileType
	 *     XFunctionCoreElementType returns XWhileType
	 *     XWhileType returns XWhileType
	 *     XWhileElementType returns XWhileType
	 *
	 * Constraint:
	 *     (expression=XExpressionType elements+=XWhileElementType*)
	 */
	protected void sequence_XWhileType(ISerializationContext context, XWhileType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
