	grammar com.dunkware.xstream.XScript with org.eclipse.xtext.common.Terminals
	
	generate xScript "http://www.dunkware.com/xstream/XScript"
	import "http://www.eclipse.org/emf/2002/Ecore" as ecore
	//TODO: AVINASHANV-11 XScript Grammar 
	/**
	 * this is huge, it is the xtext grammar that defines my DSL script, it has 4 things
	 * variables , signals , trade bots and classes. classes in this language are auto 
	 * instantiated for every entity so you can better program logic with state to generate
	 * signals. the init function allows to configure methods in the class to run at fixed
	 * interval or lisen to a signal type trigger 
	 */
	
	XScript:
		elements+=ScriptElement*;
	
	ScriptElement:
		CoreAbstractElement;
	
	CoreAbstractElement:
		VarType | XClassType | SignalType  | ScriptTree | XScriptBot | GroupType;
	
	GroupType:
		{GroupType} 'group' name=ID '('label=STRING')'';';
	
	VarType:
		"var" name=ID '(' code=INT ',' type=DataType ',' format=FormatType ',' label=STRING ',' group=[GroupType] ')' '=' expression=ExpressionType ';';
	
	ExpressionType:
		OrType;
	
	OrType returns ExpressionType:
		AndType ({OrType.left=current} "||" right=AndType)*;
	
	AndType returns ExpressionType:
		EqualityType ({AndType.left=current} "&&" right=EqualityType)*;
	
	EqualityType returns ExpressionType:
		ComparisonType ({EqualityType.left=current} op=("==" | "!=")
		right=ComparisonType)*;
	
	ComparisonType returns ExpressionType:
		PlusOrMinusType ({ComparisonType.left=current} op=(">=" | "<=" | ">" | "<")
		right=PlusOrMinusType)*;
	
	PlusOrMinusType returns ExpressionType:
		MulOrDivType (({PlusType.left=current} '+' | {MinusType.left=current} '-')
		right=MulOrDivType)*;
	
	MulOrDivType returns ExpressionType:
		PrimaryType ({MulOrDivType.left=current} op=('*' | '/')
		right=PrimaryType)*;
	
	PrimaryType returns ExpressionType:
		'(' ExpressionType ')' |
		{NotType} "!" expression=PrimaryType |
		AtomicType;
	
	AtomicType returns ExpressionType:
		AtomicBaseType;
	
	AtomicBaseType returns ExpressionType:
		{DoubleConstantType} value=DOUBLE |
		{IntConstantType} value=INT |
		{StringConstantType} value=STRING |
		{BoolConstantType} value=('true' | 'false')
		| TickExpressionType | SnapshotExpressionType | SetExpressionType | RocExpressionType | AvgExpressionType |
		VariableValueExpType
		| VariableValueRangeType | VariableValueType | SubExpressionType | VarHistoricalHighType | VarSessionHighType |
		SignalHistoricalCountType | SignalSesionCountType;
	
	
	/****************************
	 * Input Expression Types
	 ****************************/
	TickExpressionType returns ExpressionType:
		{TickExpressionType} 'tick' '(' type=INT ',' field=INT ',' dataType=DataType ')';
	
	/****************************
	 * Variable Value Expression Types
	 ****************************/
	VariableValueRangeType:
		{VariableValueRangeType} targetVar=[VarType] '[' (startIndex=INT) ',' (endIndex=INT) ']';
	
	VariableValueType:
		{VariableValueType} variable=[VarType] ('[' (indexInt=INT | 'exp' '(' expType=ExpressionType ')') ']');
	
	VariableValueExpType:
		{VariableValueExpType} 'exp' '(' expType=ExpressionType ')';
	
	SetExpressionType:
		{SetExpressionType} '{' (args+=ExpressionType (',' args+=ExpressionType)*)? '}';
	
	/**********************************
	 * Scheduled Update Expression Types
	 *********************************/
	SnapshotExpressionType:
		{SnapshotExpressionType} "snapshot" '(' target=ExpressionType ')' interval=INT time=StreamTimeUnit;
	
	/*******************************
	 * Math Exrepssion Types
	 *******************************/
	RocExpressionType:
		{RocExpressionType} "roc" '(' target=ExpressionType ',' compare=ExpressionType ')';
	
	AvgExpressionType:
		{AvgExpressionType} "avg" '(' target=SetExpressionType ')';
	
	SubExpressionType:
		{SubExpressionType} "sub" '(' target=VariableValueType ',' compare=VariableValueType ')';
	
	/*********************************
	 * Aggregation Expressions
	 **************************************/
	//HistoryTimeRange:
		//{HistoryTimeRange} 'sessions' '(' value=INT ')';
	
	SessionTimeRange:
		RelativeSessionTimeRange | TodaySessionTimeRange;
	
	RelativeSessionTimeRange:
		{RelativeSessionTimeRange} ('relative' '(' relativeVale=INT  timeUnit=SessionTimeUnit ')');
	
	TodaySessionTimeRange:
		{TodaySessionTimeRange} 'today';
	
	VarSessionHighType:
		{VarSessionHighType} 'vsh' '(' var=[VarType] ',' timeRange=SessionTimeRange ')'
	;
	
	VarHistoricalHighType:
		{VarHistoricalHighType} 'vhh' '(' var=[VarType] time=INT 'sessions'')';
	
	SignalSesionCountType:
		{SignalSesionCountType} 'ssc' '(' signal=[SignalType] ',' timeRange=SessionTimeRange ')';
	
	SignalHistoricalCountType:
		{SignalHistoricalCountType} 'shc' '(' signal=[SignalType] ',' time=INT 'sessions' ')';
	
	enum HistoricalAggFunc:
		high="HIGH" | low="LOW";
	
	enum SessionAggFunc:
		high="HIGH" | low="LOW";
	
	enum SessionTimeUnit:
		sec="sec" | min="min";
	
	/**
	 *  Trading Bot 
	 **/
	TimeType:
		{TimeType} 'time' '(' hour=INT ':' minute=INT ':' second=INT type=("AM" | "PM") ')' //
	;
	
	
	FormatType2:
		{FormatType2} type=("CURRENCY" | "TEXT" | "DATE" | "TIME" | "NUMBER" | "SHORTNUMBER" | "PERCENT" | "DECIMAL" | "DATETIME" )
	;
	
	/*******************************
	 * XScript Core Enums
	 *******************************/
	enum StreamTimeUnit:
		second="SEC" | minute="MIN" | hour="HOUR";
	
	enum DataType:
		STR | INT | BOOl | T | DT | DATE | DUB | LONG;
	
	enum FormatType:
		CURRENCY | PERCENT | NUMERIC | TEXT | DATE | TIMESTAMP | TIME | DECIMAL;
	
	terminal DOUBLE returns ecore::EDouble:
		'-'? ('0'..'9')+ '.' ('0'..'9')+ (('e' | 'E') ('-')? ('0'..'9')+)?;
	
	/*******************************
	 * XScript Signals
	 *******************************/
	SignalType:
		{SignalType} 'signal' name=ID '('id=INT ',' label=STRING ',' group=[GroupType]')' '{'
			 'desc:' desc=STRING';'			
			 (scanner=SignalScannerType)?
			'}';

	SignalScannerElementType:
		SignalScannerIntervalType | SignalScannerEntityThrottleType | SignalScannerEntityLimitType | SignalScannerScanType;
	
	SignalScannerIntervalType:
		{SignalScannerIntervalType} 'scanInterval:' interval=INT scanIntervalUnit=("sec" | "min" | "hour") ';';
	
	SignalScannerEntityThrottleType:
		{SignalScannerEntityThrottleType} 'entityThrottle:' throttle=INT entityThrottleUnit=("sec" | "min" | "hour") ';';
	
	SignalScannerEntityLimitType:
		{SignalScannerEntityLimitType} 'entityLimit:' entityLimit=INT ';';
	
	SignalScannerScanType:
		{SignalScannerScanType} 'scanType:' type=("match" | "toggle") ';';
	
	SignalScannerType:
		{SignalScannerType} 'Scanner' '{'
		'setup' '{'
		elements+=SignalScannerElementType*
		'}'
		'condition:' expression=ExpressionType ';'
		'}';
	
	/*******************************
	 * XClass Start
	 *******************************/
	XClassType returns AbstractElement:
		{XClassType} 'class' name=ID ('(' symbolFilter=STRING ')')? '{'
		elements+=XClassElementType*
		'}';
	
	XClassElementType:
		XClassCoreElementType;
	
	XClassCoreElementType:
		XFunctionType | XVarType;
	
	/****************************
	 * Global Element Types
	 *************************/
	XVarType:
		{XVarType} 'var' name=ID ('=' exp=XExpressionType)?';';
	
	XFunctionType:
		{XFunctionType} 'function' name=ID '(' (params+=[XVarType]*)? ')' '{'
		elements+=XClassFunctionElementType*
		'}';
	
	/***************************
	 * Function Element Types
	 *************************/
	XClassFunctionElementType returns XClassElementType:
		XFunctionCoreElementType;
	
	XFunctionCoreElementType:
		XFunctionReturnType | XVarType | XIfStatementType | XSignalListenerType | XStreamVarListenerType
		| XFunctionStartType | XFunctionCallType | XVarSetterType | XSignalTriggerType | XVarDecrementType
		| XSetVarType | XVarIncrementType | XDebugType | XSleepType | XWhileType;
	
	XFunctionReturnType:
		{XFunctionReturnType} 'return' (returnValue=XExpressionType)? ';';
	
	XFunctionCallType:
		{XFunctionCallType} function=[XFunctionType] '(' (params=STRING)? ')' ';';
	
	XSignalListenerType:
		{XSignalListenerType} 'signalListener' '(' signalType=[SignalType] ',' function=[XFunctionType] ')' ';';
	
	XStreamVarListenerType:
		{XStreamVarListenerType} 'streamVarListener' '(' column=[VarType] ',' function=[XFunctionType] ')' ';';
	
	XSignalTriggerType:
		{XSignalTriggerType} 'signal' '(' signal=[SignalType] ')' ';';
	
	XFunctionStartType:
		{XFunctionStartType} 'functionRunner' '(' function=[XFunctionType] ',' interval=INT time=StreamTimeUnit ')' ';';
	
	XVarSetterType:
		{XVarSetterType} var=[XVarType] '=' exp=XExpressionType ';';
	
	XVarIncrementType:
		{XVarIncrementType} var=[XVarType] '++' ';';
	
	XVarDecrementType:
		{XVarDecrementType} var=[XVarType] '--' ';';
	
	XSetVarType:
		{XSetVarType} 'setStreamVar' '(' var=[VarType] ',' value=XExpressionType ')' ';';
	
	XDebugType:
		{XDebugType} 'debug' '(' (args+=XExpressionType (',' args+=XExpressionType)*)? ')' ';';
	
	XIfStatementType:
		{XIfStatementType} 'if' '(' expression=XExpressionType ')' '{'
		elements+=XClassFunctionElementType*
		'}'
		(elseIfElements+=XElseIfStatementType*)
		(elseElement=XElseStatementType)?;
	
	XElseIfStatementType:
		{XElseIfStatementType} ('elseif' '(' expression=XExpressionType ')' '{'
		elements+=XClassFunctionElementType*
		'}');
	
	XElseStatementType:
		{XElseStatementType} 'else' '{'
		elements+=XClassFunctionElementType*
		'}';
	
	XWhileType:
		{XWhileType} 'whilst' '(' expression=XExpressionType ')' '{'
		elements+=XWhileElementType*
		'}';
	
	XWhileElementType returns XClassElementType:
		XWhileBreakType | XClassFunctionElementType;
	
	XWhileBreakType:
		{XWhileBreakType} 'break' ';';
	
	XSleepType:
		{XSleepType} 'sleep' '(' interval=INT unit=StreamTimeUnit ')' ';';
	
	/*******************
	 * Core XExpression Types
	 ********************/
	XExpressionType:
		XOrType;
	
	XOrType returns XExpressionType:
		XAndType ({XOrType.left=current} "||" right=XAndType)*;
	
	XAndType returns XExpressionType:
		XEqualityType ({XAndType.left=current} "&&" right=XEqualityType)*;
	
	XEqualityType returns XExpressionType:
		XComparisonType ({XEqualityType.left=current} op=("==" | "!=")
		right=XComparisonType)*;
	
	XComparisonType returns XExpressionType:
		XPlusOrMinusType ({XComparisonType.left=current} op=(">=" | "<=" | ">" | "<")
		right=XPlusOrMinusType)*;
	
	XPlusOrMinusType returns XExpressionType:
		XMulOrDivType (({XPlusType.left=current} '+' | {XMinusType.left=current} '-')
		right=XMulOrDivType)*;
	
	XMulOrDivType returns XExpressionType:
		XPrimaryType ({XMulOrDivType.left=current} op=('*' | '/')
		right=XPrimaryType)*;
	
	XPrimaryType returns XExpressionType:
		'(' XExpressionType ')' |
		{XNotType} "!" expression=XPrimaryType |
		XAtomicType;
	
	XAtomicType returns XExpressionType:
		XAtomicBaseType;
	
	/********************************
	 * XClass Expression Types -- added to XBooleanConstantType
	 ************************************/
	XAtomicBaseType returns XExpressionType:
		{XDoubleConstantType} value=DOUBLE |
		{XIntConstantType} value=INT |
		{XStringConstantType} value=STRING |
		{XBoolConstantType} value=('true' | 'false') | XPercentChangeExpType | XSubExpType | XVarExpType |
		XStreamWrapperExpType | XStreamVarValueExpType | XFunctionCallExpType | XVarStreakType | XVarCompareStreakType |
		XSlrAvgExpType | XLastSignalTriggerType | XSignalTriggerCountType | XVarianceAverageType | XRocExpType |
		XVarianceMaxType;
	
	XPercentChangeExpType:
		{XPercentChangeExpType} 'percentChange' '(' value1=XExpressionType "," value2=XExpressionType ')';
	
	XSubExpType:
		{XSubExpType} 'sub' '(' value1=XExpressionType "," value2=XExpressionType ')';
	
	// Returns the value of the referenced XVar
	XVarExpType:
		{XVarExpType} expVar=[XVarType];
	
	// Element for using XStream Expression type
	XStreamWrapperExpType:
		{XStreamWrapperExpType} 'exp' '(' wrapperExp=ExpressionType ')';
	
	// Element for using XClass expressions for setting the index of XStremVar to return
	XStreamVarValueExpType:
		{XStreamVarValueExpType} var=[VarType] ('[' (expressionValue=XExpressionType)) ']';
	
	XFunctionCallExpType:
		{XFunctionCallExpType} function=[XFunctionType] '(' (parms=STRING)? ')';
	
	XVarStreakType:
		{XVarStreakType} 'columnStrk' '(' var=[VarType] ',' direction=("bwd" | "fwd") ',' startIndexExp=XExpressionType ','
		(compare=XVarStreakCompareType | value=XVarStreakValueType) ')';
	
	XVarStreakCompareType:
		{XVarStreakCompareType} function=("sum" | "diff") '(' offset=INT ')' op=("<" | ">" | "=") test=DOUBLE ')';
	
	XVarStreakValueType:
		{XVarStreakValueType} 'value' op=("<" | ">" | "=") test=DOUBLE;
	
	XVarCompareStreakType:
		{XVarCompareStreakType} 'columnPairStrk' '(' targetVar=[VarType] "," compareVar=[VarType] "," direction=("bwd" |
		"fwd") ',' startIndexExp=XExpressionType "," function=("sum" | "diff" | "value" | "variance") op=("<" | ">" | "=")
		test=DOUBLE ')';
	
	XSlrAvgExpType:
		{XSlrAvgExpType} 'slrAvg' '(' var=[VarType] ',' startValue=XExpressionType "," endValue=XExpressionType ')';
	
	XLastSignalTriggerType:
		{XLastSignalTriggerType} 'lst' '(' signal=[SignalType] ')';
	
	XSignalTriggerCountType:
		{XSignalTriggerCountType} 'stc' '(' signal=[SignalType] "," lookback=INT ')';
	
	XVarianceAverageType:
		{XVarianceAverageType} 'varAvg' '(' target=[VarType] ',' compare=[VarType] ',' start=XExpressionType ","
		end=XExpressionType ')';
	
	XVarianceMaxType:
		{XVarianceMaxType} 'varMax' '(' target=[VarType] ',' compare=[VarType] ',' start=XExpressionType ","
		end=XExpressionType ')';
	
	XRocExpType:
		{XRocExpType} 'rox' '(' value1=XExpressionType "," value2=XExpressionType ')';
	
	/*******************************
	 * XClass End
	 *******************************/
	 
	 
	
	XScriptTradeOpener:
		XScriptMarketOrder | XScriptMarketPegOrder; 
	
	XScriptTradeCloser:
		XScriptMarketOrder | XScriptMarketPegOrder;
	
	XScriptMarketOrder:
		{XScriptMarketOrder}'market' '{'
			properties+=XScriptOrderProperty*
		'}';
		
	XScriptMarketPegOrder:
	{XScriptMarketPegOrder}
		'marketPegOrder' '{'
			properties+=XScriptOrderProperty*
		'}';
		
	XScriptOrderProperty:
		XScriptOrderOffset | XScriptOrderTimeout;
		
	XScriptOrderOffset:
		'offset:' offset=DOUBLE';';
		
	XScriptOrderTimeout:
		{XScriptOrderTimeout}'timeout:' value=INT timeUnit=("sec" | "min" | "hour")';';
	
	
	XScriptBotElement:
		XScriptTrade;
	
	
	XScriptBotSetup:
			XScriptEntityThrottle   | XScriptEntityLimit  | XScriptActiveCapitalLimit  | XScriptActiveEntityLimit | XScriptTradeLimit  |    XScriptWeighted;
		
	
	
	
	XScriptTradeSetup:
	XScriptEntityThrottle   | XScriptActiveCapitalLimit | XScriptEntityLimit |	XScriptWeight | XScriptSide | XScriptActiveEntityLimit | XScriptTradeLimit  |  XScriptAllocatedCapital;
	XScriptAllocatedCapital:
		{XScriptAllocatedCapital} 'allocatedCapital:' allocated=DOUBLE ';';
	XScriptActiveCapitalLimit:
		{XScriptActiveCapitalLimit} 'activeCapitalLimit:' allocated=DOUBLE ';';
	
	XScriptActiveTradeLimit:
		{XScriptActiveTradeLimit} 'activeTradeLimit:' activeTradeLimit=INT ';';
	
	XScriptTradeLimit:
		{XScriptTradeLimit} 'tradeLimit:' tradeLimit=INT ';';
	
	XScriptActiveEntityLimit:
		{XScriptActiveEntityLimit} 'activeTickerLimit:' activeEntityLimit=INT ';';
	
	XScriptEntityLimit:
		{XScriptEntityLimit} 'tickerLimit:' symbolLimit=INT ';';
	
	XScriptEntityThrottle:
		{XScriptEntityThrottle} 'tickerThrottle:' limit=INT unit=('sec' | 'min' | 'hour') ';';
	
	XScriptWeight:
		{XScriptWeight} 'weight:' weight=INT ';';
	
	XScriptSide:
		{XScriptSide} 'side:' side=("long" | "short") ';';
	
	XScriptWeighted:
		{XScriptWeighted} 'weighted:' weighted=("true" | "false") ';';
	

	
	XScriptBot: // tradeBotAlpha1(1,"Alpha 1 Bot", "Alpha Bots,
		{XScriptBot} 'tradeBot' name=ID '(' id=INT ',' label=STRING ',' group=[GroupType] ')' '{'
		'description:' description=STRING';'
		'setup' '{'
			setups+=XScriptBotSetup* // Add Playbook
		'}'
		 'trades' '{'
			trades+=XScriptTrade*
		'}'	
	
		
	'}';
	
	XScriptEntry:
		XScriptSignalEntry;
	
	XScriptSignalEntry:
		{XScriptSignalEntry} 'signal' '(' name=STRING ',' signal=[SignalType] ')' ';';
	
	XScriptTrade:
		{XScriptTrade}'trade' name=ID '(' label=STRING ')' '{'
		'desc:' description=STRING';'
		'setup' '{'
			setups+=XScriptTradeSetup*
		'}'
		'entries' '{'
			entryTypes+=XScriptEntry*
		'}'
		'opener' opener=XScriptTradeOpener
		
		'exits' '{'
			exits+=XScriptExit*
		'}'
		'closer' closer=XScriptTradeCloser
	  '}';
	XScriptExit:
		XScriptExitTimer | XScriptExitTime | XScriptStopLoss | XScriptTrailingStop | XScriptGainLossExit |
		 XScriptSignalExit | XScriptGainLossPercExit;
	
	XScriptExitTimer:
		{XScriptExitTimer} 'timer' '(' name=STRING ',' hours=INT ':' minutes=INT ':' seconds=INT ')' ';';
	
	XScriptExitTime:
		{XScriptExitTime} 'time' '(' name=STRING ',' time=TimeType ')' ';';
	
	XScriptStopLoss:
		{XScriptStopLoss} 'stopLoss' '(' name=STRING ',' percent=DOUBLE ')' ';';
	
	XScriptTrailingStop:
		{XScriptTrailingStop} 'trailingStop' '(' name=STRING ',' percent=DOUBLE ')' ';';
	
	XScriptGainLossExit:
		{XScriptGainLossExit} 'gainLoss' '(' name=STRING ',' acount=DOUBLE ')' ';';
	
	XScriptGainLossPercExit:
		{XScriptGainLossPercExit} 'gainLossPercent' '('name=STRING',' amount=DOUBLE')';
	
	
	XScriptSignalExit:
		{XScriptSignalExit} 'signal' '(' name=STRING ',' signal=[SignalType] ')' ';';
	 
	 
	 
	 
	 
	/*******************************
	 *  Script Tree
	 *******************************/
	 
	 ScriptTree:
		{ScriptTree} 'scriptTree' '('name=STRING')' '{'
				varTree=VarTree
				sigTree=SignalTree
				
		'}';
	 
	SignalTree:
		{SignalTree} 'signals' '{'
		nodes+=SignalTreeNodeElement*
		'}';
	
	SignalTreeNodeElement:
		SignalTreeNode | SignalTreeSignal;
	
	SignalTreeNode:
		{SignalTreeNode} 'node' '(' name=STRING ')' '{'
		elements+=SignalTreeNodeElement*
		'}';
	
	SignalTreeSignal:
		{SignalTreeSignal} 'signal' '(' signal=[SignalType] ',' name=STRING ')' ';';
	
	
	VarTree:
		{VarTree} 'variables' '{'
		nodes+=VarTreeNode*
		'}';
	
	VarTreeeNodeElement:
		VarTreeNode | VarTreeVar;
	
	VarTreeNode:
		{VarTreeNode} 'node' '(' name=STRING ')' '{'
		elements+=VarTreeeNodeElement*
		'}';
	
	VarTreeVar:
		{VarTreeVar} 'var' '(' var=[VarType] ',' name=STRING ')' ';';
	
	
