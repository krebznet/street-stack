grammar com.dunkware.xstream.XScript with org.eclipse.xtext.common.Terminals

generate xScript "http://www.dunkware.com/xstream/XScript"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

XScript:
	elements+=ScriptElement*;

ScriptElement:
	CoreAbstractElement;

CoreAbstractElement:
	VarType | XClassType | SignalType | BotType | ScriptTree;

VarType:
	"var" name=ID '(' code=INT ',' type=DataType ',' format=FormatType ')' '=' expression=ExpressionType ';';

ExpressionType:
	OrType;

OrType returns ExpressionType:
	AndType ({OrType.left=current} "||" right=AndType)*;

AndType returns ExpressionType:
	EqualityType ({AndType.left=current} "&&" right=EqualityType)*;

EqualityType returns ExpressionType:
	ComparisonType ({EqualityType.left=current} op=("==" | "!=")
	right=ComparisonType)*;

ComparisonType returns ExpressionType:
	PlusOrMinusType ({ComparisonType.left=current} op=(">=" | "<=" | ">" | "<")
	right=PlusOrMinusType)*;

PlusOrMinusType returns ExpressionType:
	MulOrDivType (({PlusType.left=current} '+' | {MinusType.left=current} '-')
	right=MulOrDivType)*;

MulOrDivType returns ExpressionType:
	PrimaryType ({MulOrDivType.left=current} op=('*' | '/')
	right=PrimaryType)*;

PrimaryType returns ExpressionType:
	'(' ExpressionType ')' |
	{NotType} "!" expression=PrimaryType |
	AtomicType;

AtomicType returns ExpressionType:
	AtomicBaseType;

AtomicBaseType returns ExpressionType:
	{DoubleConstantType} value=DOUBLE |
	{IntConstantType} value=INT |
	{StringConstantType} value=STRING |
	{BoolConstantType} value=('true' | 'false')
	| TickExpressionType | SnapshotExpressionType | SetExpressionType | RocExpressionType | AvgExpressionType |
	VariableValueExpType
	| VariableValueRangeType | VariableValueType | SubExpressionType | VarAggHistoryType | VarAggSessionType |
	SignalCountSession | SignalCountHistory;


/****************************
 * Input Expression Types
 ****************************/
TickExpressionType returns ExpressionType:
	{TickExpressionType} 'tick' '(' type=INT ',' field=INT ',' dataType=DataType ')';

/****************************
 * Variable Value Expression Types
 ****************************/
VariableValueRangeType:
	{VariableValueRangeType} targetVar=[VarType] '[' (startIndex=INT) ',' (endIndex=INT) ']';

VariableValueType:
	{VariableValueType} variable=[VarType] ('[' (indexInt=INT | 'exp' '(' expType=ExpressionType ')') ']');

VariableValueExpType:
	{VariableValueExpType} 'exp' '(' expType=ExpressionType ')';

SetExpressionType:
	{SetExpressionType} '{' (args+=ExpressionType (',' args+=ExpressionType)*)? '}';

/**********************************
 * Scheduled Update Expression Types
 *********************************/
SnapshotExpressionType:
	{SnapshotExpressionType} "snapshot" '(' target=ExpressionType ')' interval=INT time=StreamTimeUnit;

/*******************************
 * Math Exrepssion Types
 *******************************/
RocExpressionType:
	{RocExpressionType} "roc" '(' target=ExpressionType ',' compare=ExpressionType ')';

AvgExpressionType:
	{AvgExpressionType} "avg" '(' target=SetExpressionType ')';

SubExpressionType:
	{SubExpressionType} "sub" '(' target=VariableValueType ',' compare=VariableValueType ')';

/*********************************
 * Aggregation Expressions
 **************************************/
HistoryTimeRange:
	{HistoryTimeRange} 'relativeDays' '(' value=INT ')';

SessionTimeRange:
	RelativeSessionTimeRange | TodaySessionTimeRange;

RelativeSessionTimeRange:
	{RelativeSessionTimeRange} ('relativeTime' '(' relativeVale=INT ',' timeUnit=SessionTimeUnit ')');

TodaySessionTimeRange:
	{TodaySessionTimeRange} 'today';

VarAggSessionType:
	{VarAggSessionType} 'varAggSession' '(' var=[VarType] ',' function=SessionAggFunc ',' timeRange=SessionTimeRange ')'
;

VarAggHistoryType:
	{VarAggHistoryType} 'varAggHistory' '(' var=[VarType] ',' function=HistoricalAggFunc ',' timeRange=HistoryTimeRange
	')';

SignalCountSession:
	{SignalCountSession} 'sigCountSession' '(' signal=[SignalType] ',' timeRange=SessionTimeRange ')';

SignalCountHistory:
	{SignalCountHistory} 'sigCountHistory' '(' signal=[SignalType] ',' timeRange=HistoryTimeRange ')';

enum HistoricalAggFunc:
	high="HIGH" | low="LOW";

enum SessionAggFunc:
	high="HIGH" | low="LOW";

enum SessionTimeUnit:
	sec="SEC" | min="MIN";

/**
 *  Trading Bot 
 **/
TimeType:
	{TimeType} 'time' '(' hour=INT ':' minute=INT ':' second=INT type=("AM" | "PM") ')' //
;

BotOrderType:
	BotOrderMarketType | BotOrderMarketPegType;

BotOrderMarketType:
	{BotOrderMarketType} 'market' '(' ('timeout:' timeout=INT timeoutUnit=("sec" | "min"))? ')' ';';

BotOrderMarketPegType:
	{BotOrderMarketPegType} 'marketPeg' '(' ('timeout:' timeout=INT timeoutUnit=("sec" | "min") ',')? ('offfset' '='
	offset=DOUBLE)? ')' ';';

BotSetupElementType:
	BotActiveTradeLimitType | BotAllocatedCapitalType | BotTradeLimitType | BotSymbolLimitType |
	BotActiveSymbolLimitType
	| BotSymbolThrottleType | BotWeigtedType | BotSideType;

BotSetupPlayElementType:
	BotSetupElementType | BotWeightType;

BotAllocatedCapitalType:
	{BotAllocatedCapitalType} 'allocatedCapital:' allocated=DOUBLE ';';

BotActiveTradeLimitType:
	{BotActiveTradeLimitType} 'activeTradeLimit:' activeTradeLimit=INT ';';

BotTradeLimitType:
	{BotTradeLimitType} 'tradeLimit:' tradeLimit=INT ';';

BotActiveSymbolLimitType:
	{BotActiveSymbolLimitType} 'activeEntityLimit:' activeSymbolLimit=INT ';';

BotSymbolLimitType:
	{BotSymbolLimitType} 'entityLimit:' symbolLimit=INT ';';

BotSymbolThrottleType:
	{BotSymbolThrottleType} 'entityThrottle:' limit=INT unit=('sec' | 'min' | 'hour') ';';

BotWeightType:
	{BotWeightType} 'weight:' weight=INT ';';

BotSideType:
	{BotSideType} 'side:' side=("long" | "short") ';';

BotWeigtedType:
	{BotWeigtedType} 'weighted:' weighted=("true" | "false") ';';

BotType:
	{BotType} 'TradingBot' '(' name=STRING ',' group=STRING ')' '{'
	'setup' '{'
	setupElements+=BotSetupElementType*
	'}'
	'tradePlays' '{'
	tradePlays+=TradePlayType*
	'}'
	'}';

BotEntryType:
	BotSignalEntryType;

BotSignalEntryType:
	{BotSignalEntryType} 'signal' '(' name=STRING ',' signal=[SignalType] ')' ';';

TradePlayType:
	{TradePlayType} 'tradePlay' '(' name=STRING ')' '{'
	'setup' '{'
	elments+=BotSetupPlayElementType*
	'}'
	'entryOrderType:' entryOrder=BotOrderType
	'entryTriggers' '{'
	entryTriggers+=BotEntryType*
	'}'
	'exitOrderType' '=' exitOrder=BotOrderType
	'exitTriggers' '{'
	exitTriggers+=TradeExitType*
	'}';

TradeExitType:
	TradeExitTimmerType | TradeExitTimeType | TradeExitUplAmountType | TradeExitUplPercentType | TradeExitStopType |
	TradeExitTradilingStopType | TradeExitSignalType;

TradeExitTimmerType:
	{TradeExitTimmerType} 'timer' '(' name=STRING ',' hours=INT ',' minutes=INT ',' seconds=INT ')' ';';

TradeExitTimeType:
	{TradeExitTimeType} 'time' '(' name=STRING ',' time=TimeType ')' ';';

TradeExitStopType:
	{TradeExitStopType} 'stopLoss' '(' name=STRING ',' percent=DOUBLE ')' ';';

TradeExitTradilingStopType:
	{TradeExitTradilingStopType} 'trailingStop' '(' name=STRING ',' percent=DOUBLE ')' ';';

TradeExitUplAmountType:
	{TradeExitUplAmountType} 'unrealizedPL' '(' name=STRING ',' acount=DOUBLE ')' ';';

TradeExitUplPercentType:
	{TradeExitUplPercentType} 'unrealizedPL%' '(' name=STRING ',' percent=DOUBLE ')' ';';

TradeExitSignalType:
	{TradeExitSignalType} 'signal' '(' name=STRING ',' signal=[SignalType] ')' ';';

/*******************************
 * XScript Core Enums
 *******************************/
enum StreamTimeUnit:
	second="SEC" | minute="MIN" | hour="HOUR";

enum DataType:
	STR | INT | BOOl | T | DT | DATE | DUB | LONG;

enum FormatType:
	CURRENCY | PERCENT | NUMERIC | TEXT | DATE | TIMESTAMP | TIME | DECIMAL;

terminal DOUBLE returns ecore::EDouble:
	'-'? ('0'..'9')+ '.' ('0'..'9')+ (('e' | 'E') ('-')? ('0'..'9')+)?;

/*******************************
 * XScript Signals
 *******************************/
SignalType:
	{SignalType} 'Signal' name=ID '(' id=INT ',' label=STRING ',' group=STRING ')' ((';') | (scanner=SignalScannerType))
	?;

SignalScannerElementType:
	SignalScannerIntervalType | SignalScannerEntityThrottleType | SignalScannerEntityLimitType | SignalScannerScanType;

SignalScannerIntervalType:
	{SignalScannerIntervalType} 'scanInterval:' interval=INT scanIntervalUnit=("sec" | "min" | "hour") ';';

SignalScannerEntityThrottleType:
	{SignalScannerEntityThrottleType} 'entityThrottle:' throttle=INT entityThrottleUnit=("sec" | "min" | "hour") ';';

SignalScannerEntityLimitType:
	{SignalScannerEntityLimitType} 'entityLimit:' entityLimit=INT ';';

SignalScannerScanType:
	{SignalScannerScanType} 'scanType:' type=("match" | "toggle") ';';

SignalScannerType:
	{SignalScannerType} 'Scanner' '{'
	'setup' '{'
	elements+=SignalScannerElementType*
	'}'
	'condition:' expression=ExpressionType ';'
	'}';

/*******************************
 * XClass Start
 *******************************/
XClassType returns AbstractElement:
	{XClassType} 'class' name=ID ('(' symbolFilter=STRING ')')? '{'
	elements+=XClassElementType*
	'}';

XClassElementType:
	XClassCoreElementType;

XClassCoreElementType:
	XFunctionType | XVarType;

/****************************
 * Global Element Types
 *************************/
XVarType:
	{XVarType} 'var' name=ID ('=' exp=XExpressionType)?';';

XFunctionType:
	{XFunctionType} 'function' name=ID '(' (params+=[XVarType]*)? ')' '{'
	elements+=XClassFunctionElementType*
	'}';

/***************************
 * Function Element Types
 *************************/
XClassFunctionElementType returns XClassElementType:
	XFunctionCoreElementType;

XFunctionCoreElementType:
	XFunctionReturnType | XVarType | XIfStatementType | XSignalListenerType | XStreamVarListenerType
	| XFunctionStartType | XFunctionCallType | XVarSetterType | XSignalTriggerType | XVarDecrementType
	| XSetVarType | XVarIncrementType | XDebugType | XSleepType | XWhileType;

XFunctionReturnType:
	{XFunctionReturnType} 'return' (returnValue=XExpressionType)? ';';

XFunctionCallType:
	{XFunctionCallType} function=[XFunctionType] '(' (params=STRING)? ')' ';';

XSignalListenerType:
	{XSignalListenerType} 'signalListener' '(' signalType=[SignalType] ',' function=[XFunctionType] ')' ';';

XStreamVarListenerType:
	{XStreamVarListenerType} 'streamVarListener' '(' column=[VarType] ',' function=[XFunctionType] ')' ';';

XSignalTriggerType:
	{XSignalTriggerType} 'signal' '(' signal=[SignalType] ')' ';';

XFunctionStartType:
	{XFunctionStartType} 'functionRunner' '(' function=[XFunctionType] ',' interval=INT time=StreamTimeUnit ')' ';';

XVarSetterType:
	{XVarSetterType} var=[XVarType] '=' exp=XExpressionType ';';

XVarIncrementType:
	{XVarIncrementType} var=[XVarType] '++' ';';

XVarDecrementType:
	{XVarDecrementType} var=[XVarType] '--' ';';

XSetVarType:
	{XSetVarType} 'setStreamVar' '(' var=[VarType] ',' value=XExpressionType ')' ';';

XDebugType:
	{XDebugType} 'debug' '(' (args+=XExpressionType (',' args+=XExpressionType)*)? ')' ';';

XIfStatementType:
	{XIfStatementType} 'if' '(' expression=XExpressionType ')' '{'
	elements+=XClassFunctionElementType*
	'}'
	(elseIfElements+=XElseIfStatementType*)
	(elseElement=XElseStatementType)?;

XElseIfStatementType:
	{XElseIfStatementType} ('elseif' '(' expression=XExpressionType ')' '{'
	elements+=XClassFunctionElementType*
	'}');

XElseStatementType:
	{XElseStatementType} 'else' '{'
	elements+=XClassFunctionElementType*
	'}';

XWhileType:
	{XWhileType} 'whilst' '(' expression=XExpressionType ')' '{'
	elements+=XWhileElementType*
	'}';

XWhileElementType returns XClassElementType:
	XWhileBreakType | XClassFunctionElementType;

XWhileBreakType:
	{XWhileBreakType} 'break' ';';

XSleepType:
	{XSleepType} 'sleep' '(' interval=INT unit=StreamTimeUnit ')' ';';

/*******************
 * Core XExpression Types
 ********************/
XExpressionType:
	XOrType;

XOrType returns XExpressionType:
	XAndType ({XOrType.left=current} "||" right=XAndType)*;

XAndType returns XExpressionType:
	XEqualityType ({XAndType.left=current} "&&" right=XEqualityType)*;

XEqualityType returns XExpressionType:
	XComparisonType ({XEqualityType.left=current} op=("==" | "!=")
	right=XComparisonType)*;

XComparisonType returns XExpressionType:
	XPlusOrMinusType ({XComparisonType.left=current} op=(">=" | "<=" | ">" | "<")
	right=XPlusOrMinusType)*;

XPlusOrMinusType returns XExpressionType:
	XMulOrDivType (({XPlusType.left=current} '+' | {XMinusType.left=current} '-')
	right=XMulOrDivType)*;

XMulOrDivType returns XExpressionType:
	XPrimaryType ({XMulOrDivType.left=current} op=('*' | '/')
	right=XPrimaryType)*;

XPrimaryType returns XExpressionType:
	'(' XExpressionType ')' |
	{XNotType} "!" expression=XPrimaryType |
	XAtomicType;

XAtomicType returns XExpressionType:
	XAtomicBaseType;

/********************************
 * XClass Expression Types -- added to XBooleanConstantType
 ************************************/
XAtomicBaseType returns XExpressionType:
	{XDoubleConstantType} value=DOUBLE |
	{XIntConstantType} value=INT |
	{XStringConstantType} value=STRING |
	{XBoolConstantType} value=('true' | 'false') | XPercentChangeExpType | XSubExpType | XVarExpType |
	XStreamWrapperExpType | XStreamVarValueExpType | XFunctionCallExpType | XVarStreakType | XVarCompareStreakType |
	XSlrAvgExpType | XLastSignalTriggerType | XSignalTriggerCountType | XVarianceAverageType | XRocExpType |
	XVarianceMaxType;

XPercentChangeExpType:
	{XPercentChangeExpType} 'percentChange' '(' value1=XExpressionType "," value2=XExpressionType ')';

XSubExpType:
	{XSubExpType} 'sub' '(' value1=XExpressionType "," value2=XExpressionType ')';

// Returns the value of the referenced XVar
XVarExpType:
	{XVarExpType} expVar=[XVarType];

// Element for using XStream Expression type
XStreamWrapperExpType:
	{XStreamWrapperExpType} 'exp' '(' wrapperExp=ExpressionType ')';

// Element for using XClass expressions for setting the index of XStremVar to return
XStreamVarValueExpType:
	{XStreamVarValueExpType} var=[VarType] ('[' (expressionValue=XExpressionType)) ']';

XFunctionCallExpType:
	{XFunctionCallExpType} function=[XFunctionType] '(' (parms=STRING)? ')';

XVarStreakType:
	{XVarStreakType} 'columnStrk' '(' var=[VarType] ',' direction=("bwd" | "fwd") ',' startIndexExp=XExpressionType ','
	(compare=XVarStreakCompareType | value=XVarStreakValueType) ')';

XVarStreakCompareType:
	{XVarStreakCompareType} function=("sum" | "diff") '(' offset=INT ')' op=("<" | ">" | "=") test=DOUBLE ')';

XVarStreakValueType:
	{XVarStreakValueType} 'value' op=("<" | ">" | "=") test=DOUBLE;

XVarCompareStreakType:
	{XVarCompareStreakType} 'columnPairStrk' '(' targetVar=[VarType] "," compareVar=[VarType] "," direction=("bwd" |
	"fwd") ',' startIndexExp=XExpressionType "," function=("sum" | "diff" | "value" | "variance") op=("<" | ">" | "=")
	test=DOUBLE ')';

XSlrAvgExpType:
	{XSlrAvgExpType} 'slrAvg' '(' var=[VarType] ',' startValue=XExpressionType "," endValue=XExpressionType ')';

XLastSignalTriggerType:
	{XLastSignalTriggerType} 'lst' '(' signal=[SignalType] ')';

XSignalTriggerCountType:
	{XSignalTriggerCountType} 'stc' '(' signal=[SignalType] "," lookback=INT ')';

XVarianceAverageType:
	{XVarianceAverageType} 'varAvg' '(' target=[VarType] ',' compare=[VarType] ',' start=XExpressionType ","
	end=XExpressionType ')';

XVarianceMaxType:
	{XVarianceMaxType} 'varMax' '(' target=[VarType] ',' compare=[VarType] ',' start=XExpressionType ","
	end=XExpressionType ')';

XRocExpType:
	{XRocExpType} 'rox' '(' value1=XExpressionType "," value2=XExpressionType ')';

/*******************************
 * XClass End
 *******************************/
/*******************************
 *  Script Tree
 *******************************/
 
 ScriptTree:
	{ScriptTree} 'scriptTree' '('name=STRING')' '{'
			varTree+=VarTree
			sigTree=SignalTree
			
	'}';
 
SignalTree:
	{SignalTree} 'signalTree' '{'
	nodes+=VarTreeNode*
	'}';

SignalTreeNodeElement:
	SignalTreeNode | SignalTreeSignal;

SignalTreeNode:
	{SignalTreeNode} 'node' '(' name=STRING ')' '{'
	elements+=SignalTreeNodeElement*
	'}';

SignalTreeSignal:
	{SignalTreeSignal} 'signal' '(' signal=[SignalType] ',' name=STRING ')' ';';


VarTree:
	{VarTree} 'varTree' '{'
	nodes+=VarTreeNode*
	'}';

VarTreeeNodeElement:
	VarTreeNode | VarTreeVar;

VarTreeNode:
	{VarTreeNode} 'node' '(' name=STRING ')' '{'
	elements+=VarTreeeNodeElement*
	'}';

VarTreeVar:
	{VarTreeVar} 'var' '(' var=[VarType] ',' name=STRING ')' ';';


